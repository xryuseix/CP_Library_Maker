	"": {
		"prefix": "",
		"body": [
			"class MinCostFlow {",
			"",
			"\tint V; // 頂点数",
			"",
			"\t// 辺を表す構造体(行き先，容量，逆辺のインデックス)",
			"\tstruct edge {",
			"\t\tint to;",
			"\t\tint cap;",
			"\t\tint cost;",
			"\t\tint rev;",
			"\t};",
			"",
			"\tvector<vector<edge>> G; // グラフの隣接リスト表現",
			"\tvector<int> h; // ポテンシャル",
			"\tvector<int> prevV; // 直前の頂点",
			"\tvector<int> prevE; // 直前の辺",
			"\tvector<int> dist; // 最短距離",
			"\ttypedef pair<int, int> PI;",
			"",
			"public:",
			"\tMinCostFlow(int _v) : V(_v) {",
			"\t\tG = vector<vector<edge>>(V);",
			"\t\th = vector<int>(V);",
			"\t\tprevV = vector<int>(V);",
			"\t\tprevE = vector<int>(V);",
			"\t}",
			"",
			"\t// fromからtoへ向かう容景capの辺をグラフに追加する",
			"\tvoid add(int from, int to, int cap, int cost) {",
			"\t\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});",
			"\t\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});",
			"\t}",
			"",
			"\t// sからtへの最大流を求める",
			"\tint minCostFlow(int s, int t, int f) {",
			"\t\tint res = 0;",
			"\t\twhile (f > 0) {",
			"\t\t\t// ダイクストラ法を用いてhを更新する",
			"\t\t\tpriority_queue<PI, vector<PI>, greater<PI>> que;",
			"\t\t\tdist = vector<int>(V, INF);",
			"\t\t\tdist[s] = 0;",
			"\t\t\tque.push(PI(0, s));",
			"\t\t\twhile(!que.empty()) {",
			"\t\t\t\tPI p = que.top();",
			"\t\t\t\tque.pop();",
			"\t\t\t\tint v = p.second;",
			"\t\t\t\tif(dist[v] < p.first) continue;",
			"\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {",
			"\t\t\t\t\tedge e = G[v][i];",
			"\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
			"\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
			"\t\t\t\t\t\tprevV[e.to] = v;",
			"\t\t\t\t\t\tprevE[e.to] = i;",
			"\t\t\t\t\t\tque.push(PI(dist[e.to], e.to));",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif(dist[t] == INF) {",
			"\t\t\t\t// これ以上流せない",
			"\t\t\t\treturn -1;",
			"\t\t\t}",
			"\t\t\tfor(int v = 0; v < V; v++) {",
			"\t\t\t\th[v] += dist[v];",
			"\t\t\t}",
			"\t\t\t// s-t問最短路に沿って目一杯流す",
			"\t\t\tint d = f;",
			"\t\t\tfor(int v = t; v != s; v = prevV[v] ) {",
			"\t\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);",
			"\t\t\t}",
			"\t\t\tf -= d;",
			"\t\t\tres += d*h[t];",
			"\t\t\tfor(int v = t; v != s; v = prevV[v]) {",
			"\t\t\t\tedge& e = G[prevV[v]][prevE[v]];",
			"\t\t\t\te.cap -= d;",
			"\t\t\t\tG[v][e.rev].cap += d;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		],
		"description": ""
	}