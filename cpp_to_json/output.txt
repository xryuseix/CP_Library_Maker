	"": {
		"prefix": "",
		"body": [
			"class SegmentTree{",
			"public:",
			"\t// [a,b)の最小値を求めるセグメント木",
			"\tint n;",
			"\t// セグメント木を持つ配列",
			"\tvector<int> dat;",
			"",
			"\tSegmentTree(vi &v) {",
			"\t\tn = 1 << (int)ceil(log2(v.size()));",
			"\t\tdat = vector<int>((n<<1) - 1);",
			"\t\tfor(int i = 0; i < v.size(); i++) {",
			"\t\t\tupdate(i, v[i]);",
			"\t\t}",
			"\t\tfor(int i = v.size(); i < n; i++) {",
			"\t\t\tupdate(i, INF);",
			"\t\t}",
			"\t}",
			"",
			"\t// k番目の値(0-indexed)をxに変更",
			"\tvoid update(int k, int x) {",
			"\t\tk += n;",
			"\t\tdat[k - 1] = x;",
			"\t\tfor(k = k >> 1; k > 0; k >>= 1){",
			"\t\t\tdat[k - 1] = min(dat[2*k - 1], dat[2*k]);",
			"\t\t}",
			"\t}",
			"",
			"\t// [a, b)の最小値を求める．",
			"\tint query(int a, int b) { return query(a, b, 0, 0, n); }",
			"\tint query(int a, int b, int k, int l, int r) {",
			"\t\t// [a, b)と[l, r)が交差しなければINF",
			"\t\tif(r <= a || b <= l) {",
			"\t\t\treturn INF;",
			"\t\t}",
			"\t\t// [a, b)が[l, r)を完全に含んでいれば接点の値を返す",
			"\t\tif(a <= l && r <= b) {",
			"\t\t\treturn dat[k];",
			"\t\t} else {",
			"\t\t\t// そうでなければ２つの子の最小値を再帰的に求める",
			"\t\t\tint vl = query(a, b, k*2 + 1, l, (l + r)/2);",
			"\t\t\tint vr = query(a, b, k*2 + 2, (l + r)/2, r);",
			"\t\t\treturn min(vl, vr);",
			"\t\t}",
			"\t}",
			"\t",
			"}",
			"",
			"\tvoid show() {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i <= 2*n - 1; i++) {",
			"\t\t\tcout << dat[i - 1] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << \"\n\";",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": ""
	}