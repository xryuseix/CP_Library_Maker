	"": {
		"prefix": "",
		"body": [
			"template <typename T>",
			"class Sum {",
			"public:",
			"\t// 単位元",
			"\tT unit;",
			"\t",
			"\tSum(void) {",
			"\t\t// 単位元",
			"\t\tunit = 0;",
			"\t}",
			"",
			"\t// 演算関数",
			"\tT calc(T a, T b) {",
			"\t\treturn a + b; ",
			"\t}",
			"};",
			"",
			"template <typename T, class MONOID>",
			"class LazySegmentTree {",
			"public:",
			"\t// セグメント木の葉の要素数",
			"\tint n;",
			"",
			"\t// セグメント木",
			"\tvector<T> tree, lazy;",
			"",
			"\t// モノイド",
			"\tMONOID mono;",
			"",
			"\tLazySegmentTree(vector<T> &v) {",
			"\t\tn = 1 << (int)ceil(log2(v.size()));",
			"\t\ttree = vector<T>(n << 1);",
			"\t\tlazy = vector<T>(n << 1, mono.unit);",
			"\t\tfor(int i = 0; i < v.size(); ++i) {",
			"\t\t\tupdate(i, v[i]);",
			"\t\t}",
			"\t\tfor(int i = v.size(); i < n; ++i) {",
			"\t\t\tupdate(i, mono.unit);",
			"\t\t}",
			"\t}",
			"",
			"\t// k番目の値(0-indexed)をxに変更",
			"\tvoid update(int k, T x) {",
			"\t\tk += n;",
			"\t\ttree[k] = x;",
			"\t\tfor(k = k >> 1; k > 0; k >>= 1){",
			"\t\t\ttree[k] = mono.calc(tree[k << 1 | 0], tree[k << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\t// [l, r)の最小値(0-indexed)を求める．",
			"\tT query(int l, int r) {",
			"\t\tT res = mono.unit;",
			"\t\tl += n;",
			"\t\tr += n;",
			"\t\twhile(l < r) {",
			"\t\t\tif(l & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[l++]);",
			"\t\t\t}",
			"\t\t\tif(r & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[--r]);",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"",
			"\t// k番目のノードの遅延評価を行う",
			"\tvoid eval(int k, int l, int r) {",
			"\t\t// 遅延評価配列が空でない時，値を伝播する",
			"\t\tif(lazy[k] != mono.unit) {",
			"\t\t\ttree[k] += lazy[k];",
			"\t\t\tif(r - l > 1) {",
			"\t\t\t\tlazy[k<<1|0] += lazy[k]>>1;",
			"\t\t\t\tlazy[k<<1|1] += lazy[k]>>1;",
			"\t\t\t}",
			"",
			"\t\t\t// 伝播が終わったので自ノードの遅延配列を空にする",
			"\t\t\tlazy[k] = mono.unit;",
			"\t\t}",
			"\t}",
			"",
			"\t// 区間[l, r)にxを足す(遅延評価)",
			"\tvoid add(int l, int r, ll x) {",
			"\t\tadd(l, r, x, 1, 0, n);",
			"\t}",
			"",
			"\tvoid add(int a, int b, ll x, int k, int l, int r) {",
			"\t\t// k番目のノードに対して遅延評価を行う",
			"\t\teval(k, l, r);",
			"",
			"\t\t// 範囲外なら何もしない",
			"\t\tif(b <= l || r <= a) return;",
			"\t\t",
			"\t\t// 完全に被覆しているならば、遅延配列に値を入れた後に評価",
			"\t\tif(a <= l && r <= b) {",
			"\t\t\tlazy[k] += (r - l) * x;",
			"\t\t\teval(k, l, r);",
			"\t\t} else {",
			"\t\t\tadd(a, b, x, k<<1|0, l, (l + r)>>1);",
			"\t\t\tadd(a, b, x, k<<1|1, (l + r)>>1, r);",
			"\t\t\ttree[k] = tree[k<<1|0] + tree[k<<1|1];",
			"\t\t}",
			"\t}",
			"",
			"\t// 区間[l, r)の合計を取得する",
			"\tll getRange(int l, int r) {",
			"\t\treturn getRange(l, r, 1, 0, n);",
			"\t}",
			"",
			"\tll getRange(int a, int b, int k, int l, int r) {",
			"\t\tif(b <= l || r <= a) return mono.unit;",
			"\t\t// 関数が呼び出されたら評価！",
			"\t\teval(k, l, r);",
			"\t\tif(a <= l && r <= b) return tree[k];",
			"\t\tll vl = getRange(a, b, k<<1|0, l, (l + r)>>1);",
			"\t\tll vr = getRange(a, b, k<<1|1, (l + r)>>1, r);",
			"\t\treturn vl + vr;",
			"\t}",
			"",
			"\tT operator[](int k) {",
			"\t\t// st[i]で添字iの要素の値を返す",
			"\t\tif(k - n >= 0 || k < 0) {",
			"\t\t\treturn -INF;",
			"\t\t}",
			"\t\treturn tree[tree.size() - n + k];",
			"\t}",
			"",
			"\tvoid show(void) {",
			"\t\tshowTree();",
			"\t\tshowLazy();",
			"\t}",
			"",
			"\tvoid showTree(void) {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i < 2*n; ++i) {",
			"\t\t\tif(tree[i] == mono.unit) cout << \"UNIT \";",
			"\t\t\telse cout << tree[i] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid showLazy(void) {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i < 2*n; ++i) {",
			"\t\t\tif(lazy[i] == mono.unit) cout << \"UNIT \";",
			"\t\t\telse cout << lazy[i] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": ""
	}