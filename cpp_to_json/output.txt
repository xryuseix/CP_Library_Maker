	"kika": {
		"prefix": "kika",
		"body": [
			"/* ==== 幾何ライブラリ ==== */",
			"/* 点 */",
			"struct Point {",
			"\tdouble x;",
			"\tdouble y;",
			"\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}",
			"",
			"\t// === 四則演算の定義 ===",
			"\tfriend inline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}",
			"\tfriend inline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}",
			"\tfriend inline Point operator * (const Point &p, const double a) {return Point(p.x * a, p.y * a);}",
			"\tfriend inline Point operator * (const double a, const Point &p) {return Point(a * p.x, a * p.y);}",
			"\tfriend inline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}",
			"\tfriend inline Point operator / (const Point &p, const double a) {return Point(p.x / a, p.y / a);}",
			"",
			"\t// === その他の演算 ===",
			"\t// 反時計回りに90度回転",
			"\tfriend Point rot90(const Point &p) {return Point(-p.y, p.x);}",
			"",
			"\t// 直線b,cからみて，aがどちら側にいるか判定",
			"\t// 1: bを上cを下とした時にaが右側にある, -1: aが左側にある, 0: aは直線bc上",
			"\tfriend int simple_ccw(const Point &a, const Point &b, const Point &c) {",
			"\t\tif(OuterProduct(b-a, c-a) > EPS) return 1;",
			"\t\tif(OuterProduct(b-a, c-a) < -EPS) return -1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\t// 内積",
			"\tfriend inline double InnerProduct(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}",
			"\t// 外積",
			"\tfriend inline double OuterProduct(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}",
			"",
			"\t// 二次元のノーム(ユークリッド距離)を計算",
			"\tfriend inline double norm2(const Point &p) {return sqrt(InnerProduct(p, p));}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}",
			"};",
			"",
			"/* 線 */",
			"struct Line {",
			"\tvector<Point> line;",
			"",
			"\tLine(void) {}",
			"\t// 線分の時",
			"\tLine(Point a, Point b = Point(0.0, 0.0)) {",
			"\t\t// x座標が小さい方->y座標が小さい順にしておく",
			"\t\tif(a.x > b.x) {",
			"\t\t\tswap(a, b);",
			"\t\t} else if(a.x == b.x && a.y > b.y) {",
			"\t\t\tswap(a, b);",
			"\t\t}",
			"\t\tline.push_back(a);",
			"\t\tline.push_back(b);",
			"\t}",
			"\t// 多角形などの時",
			"\tLine(vector<Point> L) {",
			"\t\t/*",
			"\t\t// 基本はソートするとバグるのでしないこと",
			"\t\tsort(L.begin(), L.end(), [](Point const& lhs, Point const& rhs) {",
			"\t\t\tif(lhs.x != rhs.x) return lhs.x < rhs.x;",
			"\t\t\telse if(lhs.y != rhs.y) return lhs.y < rhs.y;",
			"\t\t\treturn true;",
			"\t\t});",
			"\t\t*/",
			"\t\tline = L;",
			"\t}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Line &l) {",
			"\t\ts << '{';",
			"\t\trep(i, l.line.size()) {",
			"\t\t\tif(i) {",
			"\t\t\t\ts << \", \";",
			"\t\t\t}",
			"\t\t\ts << l.line[i];",
			"\t\t}",
			"\t\ts << '}';",
			"\t\treturn s;",
			"\t}",
			"};",
			"",
			"/* 単位変換 */",
			"double torad(int deg) {return (double)(deg) * MATHPI / 180;}",
			"double todeg(double ang) {return ang * 180 / MATHPI;}",
			"",
			"/* 直線や多角形の交点 */",
			"Line crosspoint(const Line &L, const Line &M) {",
			"\tLine res;",
			"\tLine l = L;",
			"\tLine m = M;",
			"\tl.line.push_back(l.line[0]);",
			"\tm.line.push_back(m.line[0]);",
			"\tfor(int i = 0; i < l.line.size() - 1; i++) {",
			"\t\tfor(int j = 0; j < m.line.size() - 1; j++) {",
			"\t\t\tdouble d = OuterProduct(m.line[j + 1] - m.line[j], l.line[i + 1] - l.line[i]);",
			"\t\t\tif(abs(d) < EPS) continue;",
			"\t\t\tres.line.push_back(l.line[i] + (l.line[i + 1] - l.line[i]) * OuterProduct(m.line[j + 1] - m.line[j], m.line[j + 1] - l.line[i]) / d);",
			"\t\t}",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"/* 外心 */",
			"Point gaisin(const Point a, const Point b, const Point c) {",
			"\t// 外心は三角形の二つの辺の垂直二等分線の交点",
			"\tLine ab( (a + b)/2, (a + b)/2 + rot90(a - b) );",
			"\tLine bc( (b + c)/2, (b + c)/2 + rot90(b - c) );",
			"\treturn crosspoint(ab, bc).line[0];",
			"}",
			"",
			"/* 最小包含円 */",
			"double SmallestEnclosingCircle(const vector<Point> &V) {",
			"\tint N = V.size();",
			"\tif(N <= 1) return 0;",
			"",
			"\t// 最小包含円の中心の候補",
			"\tvector<Point> CenterCandidate;",
			"\tfor(int i = 0; i < N; i++) {",
			"\t\tfor(int j = i + 1; j < N; j++) {",
			"\t\t\t// 最小包含円の円弧上に点が２つしかないの時",
			"\t\t\tCenterCandidate.push_back( (V[i] + V[j]) / 2 );",
			"\t\t\tfor(int k = j + 1; k < N; k++) {",
			"\t\t\t\tif(!simple_ccw(V[i], V[j], V[k])) {",
			"\t\t\t\t\t// 三点が一直線上にある",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\t// 三点の外心が円の中心",
			"\t\t\t\tPoint r = gaisin(V[i], V[j], V[k]);",
			"\t\t\t\tCenterCandidate.push_back(r);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tdouble res = INF;",
			"\trep(c, CenterCandidate.size()) {",
			"\t\tdouble tmp = 0.0;",
			"\t\trep(v, V.size()) {",
			"\t\t\t// 中心からの距離が最大の点との距離が，包含円の半径になる",
			"\t\t\tchmax(tmp, norm2(V[v] - CenterCandidate[c]));",
			"\t\t}",
			"\t\t// 候補の包含円の中で，半径が最小の包含円が最小包含円になる．",
			"\t\tchmin(res, tmp);",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "幾何ライブラリ"
	}