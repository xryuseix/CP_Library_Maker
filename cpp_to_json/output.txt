	"": {
		"prefix": "",
		"body": [
			"class MaximumFlow {",
			"",
			"\tint v;",
			"",
			"\t// 辺を表す構造体(行き先，容量，逆辺のインデックス)",
			"\tstruct edge {",
			"\t\tint to;",
			"\t\tint cap;",
			"\t\tint rev;",
			"\t};",
			"",
			"\tvector<vector<edge>> G; // グラフの隣接リスト表現",
			"\tvector<bool> used; // DFSですでに調べたかのフラグ",
			"",
			"\t// 増加パスをDFSで探す(今いる頂点, ゴールの頂点, 今の頂点以降のフローの最小値)",
			"\tint dfs(int v, int t, int f) {",
			"\t\tif (v == t) return f;",
			"\t\tused[v] = true;",
			"\t\tfor (int i = 0; i < G[v].size(); i++) {",
			"\t\t\t// vから行ける&&cap>0の頂点を全てたどる",
			"\t\t\tedge& e = G[v][i];",
			"\t\t\tif (!used[e.to] && e.cap > 0) {",
			"\t\t\t\t// 次の頂点(e.to)以降でtまで行けるパスを探索し，その時のフローの最小値をdとする",
			"\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));",
			"\t\t\t\tif (d > 0) {",
			"\t\t\t\t\te.cap -= d;",
			"\t\t\t\t\tG[e.to][e.rev].cap += d;",
			"\t\t\t\t\treturn d;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"",
			"public:",
			"\tMaximumFlow(int _v) : v(_v) {",
			"\t\tused = vector<bool>(v);",
			"\t\tG = vector<vector<edge>>(v);",
			"\t}",
			"",
			"\t// fromからtoへ向かう容景capの辺をグラフに追加する",
			"\tvoid add(int from, int to, int cap) {",
			"\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});",
			"\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});",
			"\t}",
			"",
			"\t// sからtへの最大流を求める",
			"\tint maxFlow(int s, int t) {",
			"\t\tint flow = 0;",
			"\t\twhile (true) {",
			"\t\t\tused = vector<bool>(v);",
			"\t\t\tint f = dfs(s, t, INF);",
			"\t\t\tif (f == 0) {",
			"\t\t\t\treturn flow;",
			"\t\t\t}",
			"\t\t\tflow += f;",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": ""
	}