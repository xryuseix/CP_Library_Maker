{
	"gcd": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}"
		],
		"description": "ユークリッドの互除法"
	},
	"next_permutation": {
		"prefix": "next_permutation",
		"body": [
			"template <class BidirectionalIterator>",
			"bool generic_next_permutation(BidirectionalIterator first, BidirectionalIterator last) {",
    			"\t//要素が０又は１の場合終了",
    			"\tif (first == last) return false;",
    			"\tBidirectionalIterator second = first;",
    			"\t++second;",
    			"\tif (second == last) return false;",
 				"\tBidirectionalIterator i = last;",
    			"\t--i;   //itを最後尾にセット",
    			"\twhile (true) {",
					"\t\tBidirectionalIterator prev_i = i;",
					"\t\tif (*(--i) < *prev_i) {",
						"\t\t\tBidirectionalIterator j = last;",
						"\t\t\twhile (!(*i < *--j));",
						"\t\t\tswap(*i, *j);",
						"\t\t\treverse(prev_i, last);",
						"\t\t\treturn true;",
					"\t\t}",
					"\t\tif (i == first) {",
						"\t\t\treverse(first, last);",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
			"}"
		],
		"description": "next_permutation"
	},
	"lcm": {
		"prefix": "lcm",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}",
			"ll lcm(ll a, ll b) { return a / gcd(a,   b) * b;}"
		],
		"description": "最小公倍数"
	},
	"nlcm": {
		"prefix": "nlcm",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}",
			"ll lcm(ll a, ll b) { return a / gcd(a,   b) * b;}",
			"int nlcm(vector<int> numbers) {",
				"\tint l;",
				"\tl = numbers[0];",
				"\tfor (int i = 1; i < numbers.size(); i++) {",
					"\t\tl = lcm(l, numbers[i]);",
				"\t}",
				"\treturn l;",
			"}"
			  
		],
		"description": "n個の値の最小公倍数"
	},
	"union_find": {
		"prefix": "union_find",
		"body": [
			"class UnionFind {",
			"public:",
				"\t// 親の番号を格納する。親だった場合は-(その集合のサイズ)",
				"\tvector<int> Parent;",
				"",
				"\tUnionFind(int N) {",
					"\t\tParent = vector<int>(N, -1);",
				"\t}",
				"",
				"\t// Aがどのグループに属しているか調べる",
				"\tint root(int A) {",
					"\t\tif (Parent[A] < 0) return A;",
					"\t\treturn Parent[A] = root(Parent[A]);",
				"\t}",
				"",
				"\t// 自分のいるグループの頂点数を調べる",
				"\tint size(int A) {",
					"\t\treturn -Parent[root(A)];//親をとってきたい]",
				"\t}",
				"",
				"\t// AとBをくっ付ける",
				"\tbool connect(int A, int B) {",
					"\t\t//AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける",
					"\t\tA = root(A);",
					"\t\tB = root(B);",
					"\t\tif (A == B) {",
						"\t\t\t//すでにくっついてるからくっ付けない",
						"\t\t\treturn false;",
					"\t\t}",
					"",
					"\t\t// 大きい方(A)に小さいほう(B)をくっ付ける",
					"\t\t// 大小が逆だったらひっくり返す",
					"\t\tif (size(A) < size(B)) {",
						"\t\t\tswap(A, B);",
					"\t\t}",
					"",
					"\t\t// Aのサイズを更新する",
					"\t\tParent[A] += Parent[B];",
					"\t\t// Bの親をAに変更する",
					"\t\tParent[B] = A;",
					"",
					"\t\treturn true;",
				"\t}",
			"};"
		],
		"description": "Union-Find木"
	},
	"eratosthenes": {
		"prefix": "eratosthenes",
		"body": [
			"vector<bool> eratosmake(int n,vector<bool> num){",
				"\t//整数を列挙して素数の候補とする",
				"\tfor(int i = 0; i < n; i++) num[i] = true;",
				"\t//0と1を消す",
				"\tnum[0] = num[1] = false;",
				"\t//iを残してiの倍数を消していく",
				"\tfor(int i = 2; i < n; i++){",
					"\t\tif(num[i]){",
						"\t\t\tfor(int j = i + i; j < n; j += i){",
							"\t\t\t\tnum[j] = false;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\treturn num;",
			"}"
		],
		"description": "エラトステネスの篩"
	},
	"quicksort": {
		"prefix": "quicksort",
		"body": [
			"#define N 10",
			"int a[N];",
			"void quicksort(int a[], int first, int last){",
				"\tint i, j, x;",

				"\tx = a[(first + last)/2];",
				"\ti = first;",
				"\tj = last;",
				"\twhile(1){",
					"\t\twhile(a[i] < x) i++;",
					"\t\twhile(x < a[j]) j--;",
					"\t\tif(i >= j) break;",
					"\t\tswap(a[i], a[j]);",
					"\t\ti++;",
					"\t\tj--;",
				"\t}",
				"\tif(first < i - 1) quicksort(a, first, i - 1);",
				"\tif(j + 1 < last) quicksort(a, j + 1, last);",
			"}"
		],
		"description": "クイックソートですsort関数で十分です"
	},
	"ngcd": {
		"prefix": "ngcd",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}",
			"ll ngcd(vector<ll> a){",
			"\tll d;",
			"\td = a[0];",
			"\tfor(int i = 1; i < a.size() && d != 1; i++) d = gcd(a[i], d);",
			"\treturn d;",
			"}"
		],
		"description": "要素数がnの最大公約数"
	},
	"sanjihouteishiki":{
		"prefix": "sanjihouteishiki",
		"body": [
			"//三次方程式 ax^3+bx^2+cx+d=0を解く ",
			"double ans1=0, ans2=0, ans3=0;",

			"void cardano(double a, double b, double c, double d){",
				"\tdouble p, q, t, a3, b3, x1, x2, x3;",
				"\tb /= (3*a); c /= a; d /= a;",
				"\tp = b*b - c/3;",
				"\tq = (b*(c - 2*b*b) - d)/2;",
				"\ta = q*q - p*p*p;",
				"\tif(a == 0){",
					"\t\tq = cbrt(q); x1 = 2*q - b; x2 = -q - b;",
					"\t\tcout << \"x=\" << x1 << \", \" << x2 << \"(重解)\" << endl;",
					"\t\tans1 = x1; ans2 = x2;",
				"\t}else if(a > 0){",
					"\t\tif(q > 0) a3 = cbrt(q + sqrt(a));",
					"\t\telse   a3 = cbrt(q - sqrt(a));",
					"\t\tb3 = p/a3;",
					"\t\tx1 = a3 + b3 - b; x2 = -0.5 + (a3 + b3) - b;",
					"\t\tx3 = fabs(a3 - b3)*sqrt(3.0)/2;",
					"\t\tcout << \"x=\" << x1 << \"; \" << x2 << \"+- \" << x3 << \"i\" << endl;",
					"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
				"\t}else{",
					"\t\ta = sqrt(p); t = acos(q/(p*a)); a *= 2;",
					"\t\tx1 = a*cos(t/3) - b;",
					"\t\tx2 = a*cos((t+2*M_PI)/3) - b;",
					"\t\tx3 = a*cos((t+4*M_PI)/3) - b;",
					"\t\tcout << \"x=\" << x1 << \", \" << x2 << \", \" << x3 << endl;",
					"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
				"\t}",
			"}"
		],
		"description": "カルダノの公式を用いて三次方程式 ax^3+bx^2+cx+d=0 を解く "
	},
	"prime_dissasembly": {
		"prefix": "prime_dissasembly",
		"body": [
			"map<int,int> prime;",
			"map<int,int>::iterator it;",
			"void factorize(int x){",
				"\tint d, q;",
				"\tbool ck = true;",
				"\twhile(x >= 4 && x%2 == 0){",
					"\t\tx /= 2;",
					"\t\tif(prime.find(2) == prime.end()) prime[2] = 1;",
					"\t\telse prime[2]++;",
				"\t}",
				"\td = 3; q = x/d;",
				"\twhile(q >= d){",
					"\t\tif(x%d == 0){",
						"\t\t\tx = q;",
						"\t\t\tif(prime.find(d) == prime.end()) prime[d] = 1;",
						"\t\t\telse prime[d]++;",
					"\t\t}",
					"\t\telse if(ck){",
						"\t\t\td += 2;",
						"\t\t\tck = false;",
					"\t\t}",
					"\t\telse{",
						"\t\t\td += 4;",
						"\t\t\tck = true;",
					"\t\t}",
					"\t\tq = x/d;",
				"\t}",
				"\tif(prime.find(x) == prime.end()) prime[x] = 1;",
				"\telse prime[x]++;",
			"}"
		],
		"description": "素因数分解"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool isPrime(int x){",
				"\tint i;",
				"\tif(x < 2)return 0;",
				"\telse if(x == 2) return 1;",
				"\tif(x%2 == 0) return 0;",
				"\tfor(i = 3; i*i <= x; i += 2) if(x%i == 0) return 0;",
				"\treturn 1;",
			"}"
		],
		"description": "素数判定（ O(√N) ）"
	},
	"hakidashi": {
		"prefix": "hakidashi",
		"body": [
			"#define N 20 //20元連立方程式まで解ける",
			"/*",
			"使用方法",
				"\tdouble a[N][N+1];",
				"\tint i, n;",
				"\ta[0][0] = 2; a[0][1] = 3; a[0][2] = 1; a[0][3] = 4;",
				"\ta[1][0] = 4; a[1][1] = 1; a[1][2] = -3 ; a[1][3] = -2;",
				"\ta[2][0] = -1; a[2][1] = 2; a[2][2] = 2; a[2][3] = 2;",
				"\tn = 3;",
				"\thakidashi(a,n);",
			"*/",

			"void hakidashi(double a[][N+1], int n) { ",
				"\tdouble piv, t;",
				"\tint i, j, k;",
		
				"\tfor (k = 0; k < n; k++) {",
					"\t\tpiv = a[k][k];",
					"\t\tfor (j = k; j < n + 1; j++) {",
						"\t\t\ta[k][j] = a[k][j]/piv;",
					"\t\t}",
					"\t\tfor (i = 0; i < n; i++) {",
						"\t\t\tif (i != k) {",
							"\t\t\t\tt = a[i][k];",
							"\t\t\t\tfor (j = k; j < n+1; j++) {",
								"\t\t\t\t\ta[i][j] = a[i][j] - t*a[k][j];",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}"
		],
		"description": "掃き出し法"
	},
	"nijihouteishiki": {
		"prefix": "nijihouteishiki",
		"body": [
			"#include<cfloat>",
			"/*",
				"\taX^2+bX+c=0の解を求める",
				"\t出力はこんな感じ",
				"\tif(x1==DBL_MIN)cout<<\"解なし\"<<endl;",
				"\telse if(x1==DBL_MAX)cout<<\"不定\"<<endl;",
				"\telse if(!i)cout<<x1<<\" , \"<<x2<<endl;",
				"\telse cout<<x1<<\" +- \"<<x2<<\"i\"<<endl;",
			"*/",
			"double x1, x2;",
			"bool i = false;",
			"void quadeq(double a, double b, double c){",
				"\tdouble d, x;",
				"\tif(a != 0){",
					"\t\tb /= a; c /= a;",
					"\t\tif(c != 0){",
						"\t\t\tb /= 2;",
						"\t\t\td = b*b - c;",
						"\t\t\tif(d > 0){",
							"\t\t\t\tif(b > 0) x = -b - sqrt(d);",
							"\t\t\t\telse x = -b + sqrt(d);",
							"\t\t\t\tx1 = x; x2 = c/x;",
						"\t\t\t}else if(d < 0){",
							"\t\t\t\tx1 = -b; x2 = sqrt(-d); i = true;",
						"\t\t\t}else{",
							"\t\t\t\tx1 = x2 = -b;",
						"\t\t\t}",
					"\t\t}else{",
						"\t\t\tx1 = -b; x2 = 0;",
					"\t\t}",
				"\t}else if(b != 0){",
					"\t\tx1 = x2 = -c/b;",
				"\t}",
				"\telse if(c != 0) x1 = x2 = DBL_MIN;",
				"\telse x1 = x2 = DBL_MAX;",
			"}"
		],
		"description": "二次方程式の解を求める"
	},
	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"//vector vの中のn以下の数で最大のものを返す",
			"int bs(vector<int> v, int x){",
			"\tint ok = -1; //これがx以下 ",
			"\tint ng = v.size(); //x以上 ",
			"// 問題によってokとngを入れ替える",
			"\twhile(abs(ok - ng) > 1){",
			"\t\tint mid = (ok + ng)/2;",
			"\t\tif(v[mid] <= x) ok = mid;",
			"\t\telse ng = mid;",
			"\t}",
			"\treturn ok;",
			"}"
		],
		"description": "二分探索"
	},
	"yakusu_enum": {
		"prefix": "yakusu_enum",
		"body": [
			"vector<int> enum_div(int n){",
			"\tvector<int> ret;",
			"\tfor(int i = 1 ; i*i <= n ; ++i){",
			"\t\tif(n%i == 0){",
			"\t\t\tret.push_back(i);",
			"\t\t\tif(i != 1 && i*i != n){",
			"\t\t\t\tret.push_back(n/i);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}"
		],
		"description": "約数列挙"
	},
	"mnmod": {
		"prefix": "mnmod",
		"body": [
			"//xのn乗%modを計算",
			"ll mod_pow(ll x,ll n,ll mod){",
			"\tll res = 1;",
			"\twhile(n > 0){",
			"\t\tif(n & 1) res = res*x%mod;",
			"\t\tx = x*x%mod;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "mのn乗modPを計算"
	},
	"stringcount": {
		"prefix": "stringcount",
		"body": [
			"count(s.cbegin(), s.cend(), '$1')"
		],
		"description": "文字列中の特定の文字の個数をカウント"
	},
	"zip": {
		"prefix": "zip",
		"body": [
			"map<int,int> zip;",

			"int compress(vector<int> &x) {",
		    "\tint unzip[x.size()];",
		    "\tsort(x.begin(), x.end());",
		    "\tx.erase(unique(x.begin(),x.end()),x.end());",
		    "\tfor(int i = 0; i < x.size(); i++){",
	        "\t\tzip[x[i]] = i;",
	        "\t\tunzip[i] = x[i];",
		    "\t}",
		    "\treturn x.size();",
			"}"
		],
		"description": "一次元座標圧縮"
	},
	"bitsearch": {
		"prefix": "bitsearch",
		"body": [
			"int n = 5;",
			"",
			"// {0, 1, ..., n-1} の部分集合の全探索",
			"for (int bit = 0; bit < (1<<n); ++bit){",
			"\t/* bit で表される集合の処理を書く */",
			"\t",
			"\t/* きちんとできていることを確認してみる */",
			"\t// bit の表す集合を求める",
			"\tvector<int> S;",
			"\tfor(int i = 0; i < n; ++i) {",
			"\t\tif(bit & (1<<i) ){ // i が bit に入るかどうか",
			"\t\t\tS.push_back(i);",
			"\t\t}",
			"\t}",
			"\t",
			"\t// bit の表す集合の出力",
			"\tcout << bit << \": {\";",
			"\tfor(int  i = 0; i < S.size(); ++i) {",
			"\t\tcout << S[i] << \" \";",
			"\t}",
			"\tcout << \"}\" << endl;",
			"}"
		],
		"description": "bit全探索"
	},
	"combination": {
		"prefix": "combination",
		"body": [	
			"bool useinit = false;",
			"int combMax = 4000;",
			"vector<vector<ll> > comb(combMax + 2, vector<ll> (combMax + 2));",
			"void init(){",
				"\tcomb[0][0] = 1;",
				"\tfor(int i = 0; i <= combMax; i++){",
					"\t\tfor(int j = 0; j <= i; j++){",
						"\t\t\tcomb[i + 1][j] += comb[i][j];",
						"\t\t\tcomb[i + 1][j + 1] += comb[i][j];",
					"\t\t}",
				"\t}",
			"}",
			"int nCk(int n,int k){",
				"\tif(!useinit){",
					"\t\tinit();",
					"\t\tuseinit = true;",
				"\t}",
				"\treturn comb[n][k];",
			"}"
		],
		"description": "組み合わせ・nCkを求める"
	},
	"modint": {
		"prefix": "modint",
		"body": [
			"const int mod = 1000000007;",
			"struct mint {",
				"\tll x;",
				"\tmint(ll x=0):x(x%mod){}",
				"\tmint& operator+=(const mint a) {",
					"\t\tif ((x += a.x) >= mod) x -= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint& operator-=(const mint a) {",
					"\t\tif ((x += mod-a.x) >= mod) x -= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint& operator*=(const mint a) {",
					"\t\t(x *= a.x) %= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint operator+(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res+=a;",
				"\t}",
				"\tmint operator-(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res-=a;",
				"\t}",
				"\tmint operator*(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res*=a;",
				"\t}",
			"};"
		],
		"description": ""
	},
	"knapsack": {
		"prefix": "knapsack",
		"body": [
			"int  knapsack(int n, int W, vi w, vi v){",
				"\tvvi dp(n + 1, vi (W + 1, 0));",
				"\tfor(int i = 1; i <= n; i++) {",
					"\t\tfor(int j = 1; j <= W; j++) {",
						"\t\t\tif(j - w[i] >= 0) {",
							"\t\t\t\tchmax(dp[i][j], dp[i - 1][j - w[i]] + v[i]);",
						"\t\t\t}",
						"\t\t\tchmax(dp[i][j], dp[i - 1][j]);",
					"\t\t}",
				"\t}",
				"\treturn dp[n][W];",
			"}"
		],
		"description": "ナップサック問題を解く"
	},
	"lcs": {
		"prefix": "lcs",
		"body": [
			"string lcs(string s, string t) {",
				"\tvvi dp(s.size() + 1, vi(t.size() + 1));",
				"\t",
				"\tfor(int i = 0; i < s.size(); i++) {//LCS",
					"\t\tfor(int j = 0; j < t.size(); j++) {",
						"\t\t\tif(s[i] == t[j]) {",
							"\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;",
						"\t\t\t}",
						"\t\t\telse{",
							"\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\t//復元",
				"\tstring ans = \"\";",
				"\tint i = (int)s.size(), j = (int)t.size();",
				"\twhile (i > 0 && j > 0){",
					"\t\t// (i-1, j) -> (i, j) と更新されていた場合",
					"\t\tif (dp[i][j] == dp[i-1][j]) {",
						"\t\t\t--i; // DP の遷移を遡る",
					"\t\t}",
					"\t\t// (i, j-1) -> (i, j) と更新されていた場合",
					"\t\telse if (dp[i][j] == dp[i][j-1]) {",
						"\t\t\t--j; // DP の遷移を遡る",
					"\t\t}",
					"\t\t// (i-1, j-1) -> (i, j) と更新されていた場合",
					"\t\telse {",
						"\t\t\tans = s[i-1] + ans;",
						"\t\t\t--i, --j; // DP の遷移を遡る",
					"\t\t}",
				"\t}",
				"\treturn ans;",
			"}"
		],
		"description": "最長共通部分列問題を解く"
	},
	"template": {
		"prefix": "template",
		"body": [
			"#include <iostream>",
			"#include <algorithm>",
			"#include <string>",
			"#include <vector>",
			"using namespace std;",
			"typedef long long int ll;",
			"typedef vector<int> vi;",
			"#define rep(i,n) for(int i = 0; i < (n); ++i)",
			"int main(void){}"
		],
		"description": "テンプレート"
	},
	"gpriority_queue": {
		"prefix": "gpriority_queue",
		"body": [
			"priority_queue<int, vector<int>, greater<int> > queue;"
		],
		"description": "int型一次元で昇順に取り出せるのpriority_queue"
	},
	"bellman_ford": {
		"prefix": "bellman_ford",
		"body": [
			"// 頂点fromから頂点toへのコストcostの辺",
			"struct edge {",
				"\tint from;",
				"\tint to;",
				"\tint cost;",
			"};",
			"",
			"class Bellman_Ford{",
			"public:",
				"\tvector<edge> es; // 辺",
				"\tvector<int> d; // d[i]...頂点sから頂点iまでの最短距離",
				"\tint V, E; // Vは頂点数、Eは辺数",
				"",
				"\tBellman_Ford(int v, int e) {",
					"\t\tV = v;",
					"\t\tE = e;",
					"\t\td = vector<int>(v);",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\tedge ed = {from, to, cost};",
					"\t\tes.push_back(ed);",
				"\t}",
				"",
				"\t// s番目の頂点から各頂点への最短距離を求める",
				"\tvoid shortest_path(int s) {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\td[i] = INF;",
					"\t\t}",
					"\t\td[s] = 0;",
					"\t\twhile(true) {",
						"\t\t\tbool update = false;",
						"\t\t\tfor(int i = 0; i < E; i++) {",
							"\t\t\t\tedge e = es[i];",
							"\t\t\t\tif(d[e.from] != INF && d[e.to] > d[e.from] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[e.from] + e.cost;",
								"\t\t\t\t\tupdate = true;",
							"\t\t\t\t}",
						"\t\t\t}",
						"\t\t\tif (!update) break;",
					"\t\t}",
				"\t}",
				"\t//trueなら負の閉路が存在する",
				"\tbool is_nagative_loop() {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\td[i] = 0;",
					"\t\t}",
					"\t\tfor (int i = 0; i < 3*V; i++) {",
						"\t\t\tfor(int j = 0; j < E; j++) {",
							"\t\t\t\tedge e = es[j];",
							"\t\t\t\tif(d[e.to] > d[e.from] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[e.from] + e.cost;",
								"",
								"\t\t\t\t\t// 3n回目にも更新があるなら負の閉路が存在する",
								"\t\t\t\t\tif(i == V - 1)return true;",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn false;",
				"\t}",
			"};"
		],
		"description": "ベルマンフォード法"
	},
	"topological_sort": {
		"prefix": "topological_sort",
		"body": [
			"vvi G(1000); //グラフ(リスト)",
			"",
			"// トポロジカルソート",
			"void rec(int v, vector<bool> &seen, vector<int> &order) {",
				"\tseen[v] = true;",
				"\tcout<<v<<endl;",
				"\tfor (int i= 0; i < G[v].size(); i++) {",
					"\t\tint next = G[v][i];",
					"\t\tif (seen[next]) continue; // 既に訪問済みなら探索しない",
					"\t\trec(next, seen, order);",
				"\t}",
				"\torder.push_back(v);",
			"}",
			"",
			"vector<int> topo(int N) { // Nはノード数",
				"\t// 探索",
				"\tvector<bool> seen(N, 0); // 初期状態では全ノードが未訪問",
				"\tvector<int> order; // トポロジカルソート順",
				"\tfor (int v = 0; v < N; ++v) {",
					"\t\tif (seen[v]) continue; // 既に訪問済みなら探索しない",
					"\t\trec(v, seen, order);",
				"\t}",
				"\treverse(order.begin(), order.end());",
				"\treturn order;",
			"}"
		],
		"description": "トポロジカルソート"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"class DIJKSTRA {",
			"public:",
				"\tint V;",
				"",
				"\tstruct edge {",
					"\t\tint to;",
					"\t\tint cost;",
				"\t};",
				"",
				"\ttypedef pair<int, int> PI; //firstは最短距離、secondは頂点の番号",
				"\tvector<vector<edge> >G;",
				"\tvector<int> d; //これ答え。d[i]:=V[i]までの最短距離",
				"\tvector<int> prev; //経路復元",
				"",
				"\tDIJKSTRA(int size) {",
					"\t\tV = size;",
					"\t\tG = vector<vector<edge> >(V);",
					"\t\tprev = vector<int> (V, -1);",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\tedge e = {to, cost};",
					"\t\tG[from].push_back(e);",
				"\t}",
				"",
				"\tvoid dijkstra(int s) {",
					"\t\t//greater<P>を指定することでfirstが小さい順に取り出せるようにする",
					"\t\tpriority_queue<PI, vector<PI>, greater<PI> > que;",
					"\t\td = vector<int> (V, INF);",
					"\t\td[s] = 0;",
					"\t\tque.push(PI(0, s));",
					"",
					"\t\twhile(!que.empty()) {",
						"\t\t\tPI p = que.top();",
						"\t\t\tque.pop();",
						"\t\t\tint v = p.second;",
						"\t\t\tif(d[v] < p.first) continue;",
						"\t\t\tfor(int i = 0; i < G[v].size(); i++) {",
							"\t\t\t\tedge e = G[v][i];",
							"\t\t\t\tif(d[e.to] > d[v] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[v] + e.cost;",
								"\t\t\t\t\tprev[e.to] = v;",
								"\t\t\t\t\tque.push(PI(d[e.to], e.to));",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tvector<int> get_path(int t) {",
					"\t\tvector<int> path;",
					"\t\tfor(;t != -1; t = prev[t]) {",
						"\t\t\t//tがsになるまでprev[t]をたどっていく",
						"\t\t\tpath.push_back(t);",
					"\t\t}",
					"\t\t//このままだとt->sの順になっているので逆順にする",
					"\t\treverse(path.begin(),path.end());",
					"\t\treturn path;",
				"\t}",
				"\tvoid show() {",
					"\t\tfor(int i = 0; i < d.size()-1; i ++) {",
						"\t\t\tcout << d[i] << \" \";",
					"\t\t}",
					"\t\tcout << d[d.size()-1] << endl;",
				"\t}",
			"};"
		],
		"description": "ダイクストラ法"
	},
	"warshall_floyd": {
		"prefix": "warshall_floyd",
		"body": [
			"class WAR_FLY {",
			"public:",
				"\tvvi d; //辺の数",
				"\tint V; //頂点の数",
				"\t",
				"\tWAR_FLY(int n) {",
					"\t\tV = n;",
					"\t\td = vector<vector<int> > (n,vector<int>(n));",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tif(i == j) {",
								"\t\t\t\t\td[i][j] = 0;",
							"\t\t\t\t}",
							"\t\t\t\telse {",
								"\t\t\t\t\td[i][j] = INF;",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"",
				"\tvoid warshall_floyd() {",
					"\t\tfor(int k = 0; k < V; k++) {",
						"\t\t\tfor(int i = 0; i < V; i++) {",
							"\t\t\t\tfor(int j = 0; j < V; j++) {",
								"\t\t\t\t\td[i][j] = min((ll)d[i][j], (ll)d[i][k] + (ll)d[k][j]);",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\td[from][to] = cost;",
				"\t}",
				"",
				"\tbool is_negative_loop() {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tif(d[i][i] < 0) return true;",
					"\t\t}",
					"\t\treturn false;",
				"\t}",
				"",
				"\tvoid show() {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tcout << d[i][j] << \" \";",
						"\t\t\t}",
						"\t\t\tcout << endl;",
					"\t\t}",
				"\t}",
			"};"
		],
		"description": "ワーシャルフロイド法"
	},
	"intersect": {
		"prefix": "intersect",
		"body": [
			"set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(res, res.end()));"
		],
		"description": "setのintersect"
	},
	"digitsum": {
		"prefix": "digitsum",
		"body": [
			"int digsum(int n) {",
				"\tint res = 0;",
				"\twhile(n > 0) {",
					"\t\tres += n%10;",
					"\t\tn /= 10;",
				"\t}",
				"\treturn res;",
			"}"
		],
		"description": "桁和"
	},
	"indexdintance": {
		"prefix": "indexdistance",
		"body": [
			"static_cast<int>(std::distance(std::begin(array), std::find(std::begin(array), std::end(array), $1c)))"
		],
		"description": "特定の文字の配列内の添字"
	},
	"gyakugen": {
		"prefix": "gyakugen",
		"body": [
			"// (a/b)%P の場合は，(a%P)*modinv(b)%P とする",
			"ll modinv(ll a) {",
    			"\tll b = MOD, u = 1, v = 0;",
    			"\twhile (b) {",
					"\t\tll t = a / b;",
        			"\t\ta -= t * b; swap(a, b);",
        			"\t\tu -= t * v; swap(u, v);",
				"\t}",
    			"\tu %= MOD;",
    			"\tif (u < 0) u += MOD;",
    			"\treturn u;",
			"}"
		],
		"description": "逆元の計算"
	},
	"BoyerMoore": {
		"prefix": "BoyerMoore",
		"body": [
			"class BoyerMoore {",
				"\tpublic:",
				"\tstring text;",
				"\tstring pattern;",
				"\tint n;",
				"\tint m;",
				"\tmap<char, int> lambda;",
				"\tBoyerMoore(string text_, string pattern_) : ",
					"\t\ttext(text_), pattern(pattern_), n(text_.size()), m(pattern_.size()) {",
					"\t\tcompute_lambda();",
				"\t};",
				"\tvoid compute_lambda() {",
					"\t\tfor(int j = 1; j <= m; j++) {",
						"\t\t\tlambda[pattern.at(j - 1)] = j;",
					"\t\t}",
				"\t};",
				"\tint get_lambda(const char& c) {",
					"\t\tif (lambda.find(c) != lambda.end()) {",
						"\t\t\treturn lambda[c];",
					"\t\t} else {",
						"\t\t\treturn 0;",
					"\t\t}",
				"\t};",
				"\tbool match() {",
					"\t\tint s = 0;",
					"\t\twhile(s <= n - m) {",
						"\t\t\tint j = m;",
						"\t\t\twhile(j > 0 && pattern.at(j - 1) == text.at(s + j - 1)) {",
							"\t\t\t\tj--;",
						"\t\t\t}",
						"\t\t\tif(j == 0) {",
							"\t\t\t\treturn true;//ここを消すとsが文字列の位置を示す",
							"\t\t\t\ts++;",
						"\t\t\t} else {",
							"\t\t\t\ts += std::max(1, j - get_lambda(text.at(s + j - 1)));",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn false;",
				"\t};",
			"};"
		],
		"description": "BoyerMoore法(文字列探索アルゴリズム)"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"//Union-Findも呼んで！！",
			"struct edge {",
				"\tint u; //辺の片方，fromではないので二回辺を張る必要はない",
				"\tint v; //辺のもう片方",
				"\tint cost;",
				"",
				"\t// コストの大小で順序定義",
				"\tbool operator<(const edge& e) const {",
					"\t\treturn cost < e.cost;",
				"\t}",
			"};",
			"class Kruskal{",
				"\tpublic:",
				"",
				"\tbool comp(const edge& e1, const edge& e2) { //sort関数の比較関数",
					"\t\treturn e1.cost < e2.cost;",
				"\t}",
				"",
				"\tvector<edge> es; //辺の集合",
				"\tvector<edge> minst; //最小全域木に用いられる辺の集合",
				"\tint V, E; //頂点数と辺数",
				"",
				"\tKruskal(int v) {",
					"\t\tV = v;",
				"\t}",
				"",
				"\tvoid add(int v, int u, int cost){",
					"\t\tedge e = {v, u, cost};",
					"\t\tes.push_back(e);",
				"\t}",
				"",
				"\tint kruskal() {",
					"\t\tsort(es.begin(), es.end()); //edge.costが小さい順にソートされる",
					"\t\tUnionFind uni(V); //union-findの初期化",
					"\t\tint res = 0;",
					"\t\tfor(int i = 0; i < es.size(); i++) {",
						"\t\t\tedge e = es[i];",
						"\t\t\tif(uni.root(e.u) != uni.root(e.v)) {",
							"\t\t\t\tuni.connect(e.u, e.v);",
							"\t\t\t\tres += e.cost;",
							"\t\t\t\tminst.push_back(e);",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn res;",
				"\t}",
				"",
				"\tvoid show(){",
					"\t\tvvi v(V, vi(V, -1));",
					"\t\tfor(int i = 0; i < minst.size(); i++) {",
						"\t\t\tv[minst[i].u][minst[i].v] = minst[i].cost;",
						"\t\t\tv[minst[i].v][minst[i].u] = minst[i].cost;",
					"\t\t}",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tif(v[i][j] == -1) {",
								"\t\t\t\t\tprintf(\"  __ \");",
							"\t\t\t\t} else {",
								"\t\t\t\t\tprintf(\"%4d \", v[i][j]);",
							"\t\t\t\t}",
						"\t\t\t}",
						"\t\t\tcout << endl;",
					"\t\t}",
				"\t}",
			"};"
		],
		"description": "クラスカル法"
	},
	"hutei": {
		"prefix": "hutei",
		"body": [	
			"void hutei(int a, int b, int c, bool minus) {",
				"\tvector<int> arr;",
				"",
				"\t// A / B = div...mod",
				"\tint A = max(a, b);",
				"\tint B = min(a, b);",
				"\tint div, mod;",
				"",
				"\twhile(1) {",
					"\t\tdiv = A/B;",
					"\t\tmod = A%B;",
					"\t\tarr.push_back(div);",
					"",
					"\t\tA = B;",
					"\t\tB = mod;",
					"",
					"\t\tif(mod == 1) {",
						"\t\t\tbreak;",
					"\t\t}",
				"\t}",
				"",
				"\tvector<vector<int> > calc(2, vector<int> (arr.size() + 1, INF));",
				"",
				"\tfor(int i = 0; i < arr.size() - 1; i++) {",
					"\t\tcalc[0][i] = -arr[i];",
				"\t}",
				"\tcalc[1][arr.size() - 1] = -arr[arr.size() - 1];",
				"\tcalc[1][arr.size()] = 1;",
				"",
				"\tfor(int i = arr.size()-2; i >= 0; i--) {",
					"\t\tcalc[1][i] = calc[0][i]*calc[1][i + 1] + calc[1][i + 2];",
				"\t}",
				"",
				"\tint x = calc[1][0]*c;",
				"\tint y = calc[1][1]*c;",
				"",
				"\tif(minus) {",
					"\t\ty *= -1;",
				"\t}",
				"\tcout << a << \"(\" << b << \"m + \" << x << \")\";",
				"\tif(minus) {",
					"\t\tcout << \" - \";",
				"\t} else {",
					"\t\tcout << \" + \";",
				"\t}",
				"\tcout << b << \"(\" << a << \"m + \" << y << \")\" << \" = \" << c << endl;",
			"}"
		],
		"description": "不逞方程式を解く"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"class SegmentTree{",
			"public:",
				"\t// [a,b)の最小値を求めるセグメント木",
				"\tint n;",
				"\t// セグメント木を持つ配列",
				"\tvector<int> dat;",
				"",
				"\tSegmentTree(vi v) {",
					"\t\tn = calc2(v.size());",
					"\t\tvector<int> tmp(n*2 - 1);",
					"\t\tdat = tmp;",
					"\t\tfor(int i = 0; i < dat.size(); i++) {",
						"\t\t\tdat[i] = INF; // 最大値を求めるときはここを変える(1)",
					"\t\t}",
					"\t\tfor(int i = 0; i < v.size(); i++) {",
						"\t\t\tupdate(i, v[i]);",
					"\t\t}",
				"\t}",
				"",
				"\t// Nより大きい２のべき乗数nを計算",
				"\tint calc2(int N){",
					"\t\tint n = 1;",
					"\t\twhile(n < N) {",
						"\t\t\tn *= 2;",
					"\t\t}",
					"\t\treturn n;",
				"\t}",
				"",
				"\t// k番目の値(0-indexed)をaに変更",
				"\tvoid update(int k, int a) {",
					"\t\tk += n - 1;",
					"\t\tdat[k] = a;",
					"\t\t//登りながら更新",
					"\t\twhile(k > 0) {",
						"\t\t\tk = (k - 1)/2;",
						"\t\t\tdat[k] = min(dat[k*2 + 1], dat[k*2 + 2]); // 最大値を求めるときはここを変える(2)",
					"\t\t}",
				"\t}",
				"",
				"\t// [a, b)の最小値を求める．",
				"\tint query(int a, int b) { return query(a, b, 0, 0, n); }",
				"\tint query(int a, int b, int k, int l, int r) {",
					"\t\t// [a, b)と[l, r)が交差しなければINF",
					"\t\tif(r <= a || b <= l) {",
						"\t\t\treturn INF; // 最大値を求めるときはここを変える(3)",
					"\t\t}",
					"\t\t// [a, b)が[l, r)を完全に含んでいれば接点の値を返す",
					"\t\tif(a <= l && r <= b) {",
						"\t\t\treturn dat[k];",
					"\t\t} else {",
						"\t\t\t// そうでなければ２つの子の最小値を再帰的に求める",
						"\t\t\tint vl = query(a, b, k*2 + 1, l, (l + r)/2);",
						"\t\t\tint vr = query(a, b, k*2 + 2, (l + r)/2, r);",
						"\t\t\treturn min(vl, vr); // 最大値を求めるときはここを変える(4)",
					"\t\t}",
				"\t}",
				"",
				"\tvoid show() {",
					"\t\tint ret = 2;",
					"\t\tfor(int i = 1; i <= 2*n - 1; i++) {",
						"\t\t\tcout << dat[i - 1] << \" \";",
						"\t\t\tif(i == ret - 1) {",
							"\t\t\t\tcout << \"\\n\";",
							"\t\t\t\tret *= 2;",
						"\t\t\t}",
					"\t\t}",
					"\t\tcout << endl;",
				"\t}",
			"};"
		],
		"description": "セグメント木"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"int lis(vector<int>& v) {",
    			"\tvvi dp(1, v[0]);",
    			"\tfor(int i = 1; i < v.size(); i++) {",
    			    "\t\tif(v[i] > dp[dp.size() - 1]) {",
    			        "\t\t\tdp.push_back(v[i]);",
    			    "\t\t} else {",
    			        "\t\t\tint pos = distance(lower_bound(dp.begin(), dp.end(), v[i]), dp.begin());",
    			        "\t\t\tdp[pos] = v[i];",
    			    "\t\t}",
    			"\t}",
    			"\treturn (int)dp.size();",
			"}"
		],
		"description": "LIS(最長増加部分列)を解く"
	},
	"conlis": {
		"prefix": "conlis",
		"body": [
			"int conlis(vector<int>& v) {",
    			"\tvi dp(v.size() + 1, 0);",
    			"\tint ans = 0;",
    			"\tfor(int i = 0; i < v.size(); i++) {",
        			"\t\tdp[v[i]] = dp[v[i] - 1] + 1;",
        			"\t\tans = max(ans, dp[v[i]]);",
    			"\t}",
    			"\treturn ans;",
			"}"
		],
		"description": "Continue LIS(最長連続増加部分列)を解く"
	},
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"// x,y に ax + by = gcd(a, b) を満たす値が格納される",
			"ll extgcd(ll a, ll b, ll &x, ll &y) {",
				"\tif (b == 0) {",
					"\t\tx = 1;",
					"\t\ty = 0;",
					"\t\treturn a;",
				"\t}",
				"\tll d = extgcd(b, a%b, y, x);",
				"\ty -= a/b * x;",
				"\treturn d;",
			"}"
		],
		"description": "拡張ユークリッドの互助法を解く"
	},
	"StronglyConnectedComponent": {
		"prefix": "StronglyConnectedComponent",
		"body": [
			"class StronglyConnectedComponent {",
			"public:",
			"\tint V;          // 頂点数",
			"\tint SubGraph;   // 強連結成分の数",
			"\tvvi Graph;      // グラフの隣接リスト表現",
			"\tvvi revGraph;   // 辺の向きを逆にしたグラフ",
			"\tvvi SmallGraph; // 強連結成分分解によって縮めたグラフ",
			"\tvi dfsline;     // 帰りがけ順の並び",
			"\tvi compo;       // cmp[i]で頂点iの属するグループ",
			"\tvb used;        // すでに調べたか",
			"",
			"\tStronglyConnectedComponent(int v) {",
			"\t\tV = v;",
			"\t\tGraph = vvi(v);",
			"\t\trevGraph = vvi(v);",
			"\t\tused = vb(v);",
			"\t\tcompo = vi(v);",
			"\t}",
			"",
			"\tint operator[](int k) {",
			"\t\t// scc[i]でi番目の頂点のグループ番号を返す",
			"\t\treturn compo[k];",
			"\t}",
			"",
			"\tvoid add_edge(int from, int to) {",
			"\t\tGraph[from].push_back(to);",
			"\t\trevGraph[to].push_back(from);",
			"\t}",
			"",
			"\tvoid dfs(int v) {",
			"\t\tused[v] = true;",
			"\t\tfor(int i = 0; i < Graph[v].size(); i++) {",
			"\t\t\tif(!used[Graph[v][i]]) dfs(Graph[v][i]);",
			"\t\t}",
			"\t\tdfsline.push_back(v);",
			"\t}",
			"",
			"\tvoid revdfs(int v, int k) {",
			"\t\tused[v] = true;",
			"\t\tcompo[v] = k;",
			"\t\tfor(int i = 0; i < revGraph[v].size(); i++) {",
			"\t\t\tif(!used[revGraph[v][i]]) revdfs(revGraph[v][i], k);",
			"\t\t}",
			"\t}",
			"",
			"\tint scc() {",
			"\t\tused = vb((int)used.size(), false);",
			"\t\tdfsline.clear();",
			"\t\tfor(int v = 0; v < V; v++) {",
			"\t\t\tif(!used[v]) dfs(v);",
			"\t\t}",
			"\t\tused = vb(used.size(), false);",
			"\t\tSubGraph = 0;",
			"\t\tfor(int i = dfsline.size() - 1; i >= 0; i--) {",
			"\t\t\tif(!used[dfsline[i]]) revdfs(dfsline[i], SubGraph++);",
			"\t\t}",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tcompo[i] = SubGraph - compo[i] - 1;",
			"\t\t}",
			"\t\treturn SubGraph;",
			"\t}",
			"",
			"\tvoid build() {",
			"\t\t// 縮めたグラフを構築する",
			"\t\tSmallGraph = vvi(SubGraph);",
			"\t\tfor (int i = 0; i < Graph.size(); i++) {",
			"\t\t\tfor(int j = 0; j < Graph[i].size(); j++) {",
			"\t\t\t\tint to = Graph[i][j];",
			"\t\t\t\tint s = compo[i], t = compo[to];",
			"\t\t\t\tif (s != t){",
			"\t\t\t\t\tSmallGraph[s].push_back(t);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\t// 被った辺を削除",
			"\t\t\tSmallGraph[i].erase(unique(SmallGraph[i].begin(), SmallGraph[i].end()), SmallGraph[i].end());",
			"\t\t}",
			"\t}",
			"",
			"\tvoid show_set_to_edge() {",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"集合\" << i << \"から出ている辺 : \";",
			"\t\t\tfor(int j = 0; j < SmallGraph[i].size(); j++) {",
			"\t\t\t\tcout << SmallGraph[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_group_of_node() {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tcout << \"頂点\" << i << \"の属するグループ : \" << compo[i] << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_node_in_group() {",
			"\t\tvvi group(SubGraph);",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tgroup[compo[i]].push_back(i);",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"グループ\" << i << \"に属する頂点 : \";",
			"\t\t\tfor(int j = 0; j < group[i].size(); j++) {",
			"\t\t\t\tcout << group[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "強連結成分分解"
	},
	"CoordinateCompression": {
		"prefix": "CoordinateCompression",
		"body": [
			"class Compress{",
			"public:",
			"\tint before_W, before_H, N;",
			"\tvi before_X1, before_X2, before_Y1, before_Y2;",
			"\tint after_W, after_H;",
			"\tvi after_X1, after_X2, after_Y1, after_Y2;",
			"\t",
			"\t// (x1,y1) -> (x2, y2) の直線上のマスが塗られているとする",
			"\t// 点の場合は (x1,y1) == (x2, y2) とする",
			"\t// 四角形の場合は直線の集合とする",
			"\tCompress(int max_h, int max_w, int n, vi x1, vi x2, vi y1, vi y2) {",
			"\t\tbefore_H = max_h;",
			"\t\tbefore_W = max_w;",
			"\t\tN = n;",
			"\t\tbefore_X1 = x1;",
			"\t\tbefore_X2 = x2;",
			"\t\tbefore_Y1 = y1;",
			"\t\tbefore_Y2 = y2;",
			"\t\tafter_X1 = vi(max_w);",
			"\t\tafter_X2 = vi(max_w);",
			"\t\tafter_Y1 = vi(max_h);",
			"\t\tafter_Y2 = vi(max_h);",
			"\t}",
			"",
			"\tvoid compress() {",
			"\t\tafter_W = exec_compress(before_X1, before_X2, after_X1, after_X2, before_W, \"width\");",
			"\t\tafter_H = exec_compress(before_Y1, before_Y2, after_Y1, after_Y2, before_H, \"height\");",
			"\t}",
			"",
			"\tvoid before_show() {",
			"\t\tvvc v(before_H, vc(before_W, '_'));",
			"\t\tcout << \"H = \" << before_H << \", W = \" << before_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = before_Y1[i]; y <= before_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = before_X1[i]; x <= before_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, before_H){",
			"\t\t\trep(j, before_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid after_show() {",
			"\t\tvvc v(after_H, vc(after_W, '_'));",
			"\t\tcout << \"H = \" << after_H << \", W = \" << after_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = after_Y1[i]; y <= after_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = after_X1[i]; x <= after_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, after_H){",
			"\t\t\trep(j, after_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"private:",
			"\tint exec_compress(vi &z1, vi &z2, vi &aft_z1, vi &aft_z2, int max_len, string mode) {",
			"\t\tvector<int> zs;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tif(z1[i] > z2[i]) swap(z1[i], z2[i]);",
			"",
			"\t\t\tzs.push_back(z1[i]);",
			"\t\t\tzs.push_back(z2[i]);",
			"",
			"\t\t\tif(mode == \"width\") {",
			"\t\t\t\tif(z2[i] + 1 <= max_len) zs.push_back(z2[i] + 1);",
			"\t\t\t} else if(mode == \"height\") {",
			"\t\t\t\tif(0 < z1[i] - 1) zs.push_back(z1[i] - 1);",
			"\t\t\t}",
			"\t\t}",
			"\t\tzs.push_back(1);",
			"\t\tzs.push_back(max_len);",
			"",
			"\t\tsort(zs.begin(), zs.end());",
			"\t\tzs.erase(unique(zs.begin(), zs.end()), zs.end());",
			"",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\taft_z1[i] = find(zs.begin(), zs.end(), z1[i]) - zs.begin() + 1;",
			"\t\t\taft_z2[i] = find(zs.begin(), zs.end(), z2[i]) - zs.begin() + 1;",
			"\t\t}",
			"\t\treturn zs.size();",
			"\t}",
			"};"
		],
		"description": "二次元座標圧縮"
	}
}


