
{
	"gcd": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}"
		],
		"description": "ユークリッドの互除法"
	},
	"lcm": {
		"prefix": "lcm",
		"body": [
			"// gcdも呼ぶ！！！",
			"ll lcm(ll a, ll b) { return a / gcd(a,   b) * b;}"
		],
		"description": "最小公倍数"
	},
	"nlcm": {
		"prefix": "nlcm",
		"body": [
			"// gcdも呼ぶ！！！",
			"// lcmも呼ぶ！！！",
			"ll nlcm(vector<ll> numbers) {",
			"\tll l = numbers[0];",
			"\tfor (int i = 1; i < numbers.size(); i++) {",
			"\t\tl = lcm(l, numbers[i]);",
			"\t}",
			"\treturn l;",
			"}"
		],
		"description": "n個の値の最小公倍数"
	},
	"union_find": {
		"prefix": "union_find",
		"body": [
			"class UnionFind {",
			"public:",
			"\t// 親の番号を格納．親だった場合は-(その集合のサイズ)",
			"\tvector<int> Parent;",
			"\t// 重さの差を格納",
			"\tvector<ll> diffWeight;",
			"",
			"\tUnionFind(const int N) {",
			"\t\tParent = vector<int>(N, -1);",
			"\t\tdiffWeight = vector<ll>(N, 0);",
			"\t}",
			"",
			"\t// Aがどのグループに属しているか調べる",
			"\tint root(const int A) {",
			"\t\tif (Parent[A] < 0) return A;",
			"\t\tint Root = root(Parent[A]);",
			"\t\tdiffWeight[A] += diffWeight[Parent[A]];",
			"\t\treturn Parent[A] = Root;",
			"\t}",
			"",
			"\t// 自分のいるグループの頂点数を調べる",
			"\tint size(const int A) {",
			"\t\treturn -Parent[root(A)];",
			"\t}",
			"",
			"\t// 自分の重さを調べる",
			"\tll weight(const int A) {",
			"\t\troot(A); // 経路圧縮",
			"\t\treturn diffWeight[A];",
			"\t}",
			"",
			"\t// 重さの差を計算する",
			"\tll diff(const int A, const int B) {",
			"\t\treturn weight(B) - weight(A);",
			"\t}",
			"",
			"\t// AとBをくっ付ける",
			"\tbool connect(int A, int B, ll W = 0) {",
			"\t\t// Wをrootとの重み差分に変更",
			"\t\tW += weight(A);",
			"\t\tW -= weight(B);",
			"",
			"\t\t// AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける",
			"\t\tA = root(A);",
			"\t\tB = root(B);",
			"",
			"\t\tif (A == B) {",
			"\t\t\t//すでにくっついてるからくっ付けない",
			"\t\t\treturn false;",
			"\t\t}",
			"",
			"\t\t// 大きい方(A)に小さいほう(B)をくっ付ける",
			"\t\t// 大小が逆だったらひっくり返す",
			"\t\tif (size(A) < size(B)) {",
			"\t\t\tswap(A, B);",
			"\t\t\tW = -W;",
			"\t\t}",
			"",
			"\t\t// Aのサイズを更新する",
			"\t\tParent[A] += Parent[B];",
			"\t\t// Bの親をAに変更する",
			"\t\tParent[B] = A;",
			"",
			"\t\t// AはBの親であることが確定しているのでBにWの重みを充てる",
			"\t\tdiffWeight[B] = W;",
			"",
			"\t\treturn true;",
			"\t}",
			"};"
		],
		"description": "Union-Find木"
	},
	"eratosthenes": {
		"prefix": "eratosthenes",
		"body": [
			"class Sieve{",
			"\tint N;",
			"\tvoid eratosmake(void) {",
			"\t\t// iを残してiの倍数を消していく",
			"\t\tfor(int i = 2; i < N; i++) {",
			"\t\t\tif(nums[i] == 1) {",
			"\t\t\t\tfor(int j = i + i; j < N; j += i){",
			"\t\t\t\t\tnums[j] = i;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tvector<int> nums;",
			"\tSieve(int n):N(n){",
			"\t\tnums = vi(n+1, 1);",
			"\t\teratosmake();",
			"\t}",
			"\tbool isPrime(int n) {",
			"\t\treturn nums[n] == 1;",
			"\t}",
			"\tint minPrimeFactor(int n) {",
			"\t\treturn nums[n];",
			"\t}",
			"};"
		],
		"description": "エラトステネスの篩"
	},
	"ngcd": {
		"prefix": "ngcd",
		"body": [
			"// gcdも呼ぶ！！！",
			"ll ngcd(vector<ll> a){",
			"\tll d;",
			"\td = a[0];",
			"\tfor(int i = 1; i < a.size() && d != 1; i++) d = gcd(a[i], d);",
			"\treturn d;",
			"}"
		],
		"description": "要素数がnの最大公約数"
	},
	"sanjihouteishiki": {
		"prefix": "sanjihouteishiki",
		"body": [
			"// 三次方程式 ax^3+bx^2+cx+d=0を解く ",
			"double ans1=0, ans2=0, ans3=0;",
			"void cardano(double a, double b, double c, double d){",
			"\tdouble p, q, t, a3, b3, x1, x2, x3;",
			"\tb /= (3*a); c /= a; d /= a;",
			"\tp = b*b - c/3;",
			"\tq = (b*(c - 2*b*b) - d)/2;",
			"\ta = q*q - p*p*p;",
			"\tif(a == 0){",
			"\t\tq = cbrt(q); x1 = 2*q - b; x2 = -q - b;",
			"\t\tcout << \"x=\" << x1 << \", \" << x2 << \"(重解)\" << endl;",
			"\t\tans1 = x1; ans2 = x2;",
			"\t}else if(a > 0){",
			"\t\tif(q > 0) a3 = cbrt(q + sqrt(a));",
			"\t\telse   a3 = cbrt(q - sqrt(a));",
			"\t\tb3 = p/a3;",
			"\t\tx1 = a3 + b3 - b; x2 = -0.5 + (a3 + b3) - b;",
			"\t\tx3 = fabs(a3 - b3)*sqrt(3.0)/2;",
			"\t\tcout << \"x=\" << x1 << \"; \" << x2 << \"+- \" << x3 << \"i\" << endl;",
			"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
			"\t}else{",
			"\t\ta = sqrt(p); t = acos(q/(p*a)); a *= 2;",
			"\t\tx1 = a*cos(t/3) - b;",
			"\t\tx2 = a*cos((t+2*M_PI)/3) - b;",
			"\t\tx3 = a*cos((t+4*M_PI)/3) - b;",
			"\t\tcout << \"x=\" << x1 << \", \" << x2 << \", \" << x3 << endl;",
			"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
			"\t}",
			"}"
		],
		"description": "カルダノの公式を用いて三次方程式 ax^3+bx^2+cx+d=0 を解く "
	},
	"prime_dissasembly": {
		"prefix": "prime_dissasembly",
		"body": [
			"map<ll, ll> prime;",
			"void factorize(ll n) {",
			"\tfor(ll i = 2; i * i <= n; i++) {",
			"\t\twhile(n % i == 0) {",
			"\t\t\tprime[i]++;",
			"\t\t\tn /= i;",
			"\t\t}",
			"\t}",
			"\tif(n != 1) {",
			"\t\tprime[n] = 1;",
			"\t}",
			"}"
		],
		"description": "素因数分解"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool isPrime(ll x){",
			"\tif(x < 2)return 0;",
			"\telse if(x == 2) return 1;",
			"\tif(x%2 == 0) return 0;",
			"\tfor(ll i = 3; i*i <= x; i += 2) if(x%i == 0) return 0;",
			"\treturn 1;",
			"}"
		],
		"description": "素数判定（ O(√N) ）"
	},
	"hakidashi": {
		"prefix": "hakidashi",
		"body": [
			"#define RANK 20 // 20元連立方程式まで解ける",
			"/*",
			"使用方法",
			"\tdouble a[RANK][RANK+1];",
			"\tint i, n;",
			"\ta[0][0] = 2; a[0][1] = 3; a[0][2] = 1; a[0][3] = 4;",
			"\ta[1][0] = 4; a[1][1] = 1; a[1][2] = -3 ; a[1][3] = -2;",
			"\ta[2][0] = -1; a[2][1] = 2; a[2][2] = 2; a[2][3] = 2;",
			"\tn = 3;",
			"\thakidashi(a,n);",
			"*/",
			"void hakidashi(double a[][RANK+1], int n) { ",
			"\tdouble piv, t;",
			"\tint i, j, k;",
			"\tfor (k = 0; k < n; k++) {",
			"\t\tpiv = a[k][k];",
			"\t\tfor (j = k; j < n + 1; j++) {",
			"\t\t\ta[k][j] = a[k][j]/piv;",
			"\t\t}",
			"\t\tfor (i = 0; i < n; i++) {",
			"\t\t\tif (i != k) {",
			"\t\t\t\tt = a[i][k];",
			"\t\t\t\tfor (j = k; j < n+1; j++) {",
			"\t\t\t\t\ta[i][j] = a[i][j] - t*a[k][j];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "掃き出し法"
	},
	"nijihouteishiki": {
		"prefix": "nijihouteishiki",
		"body": [
			"/*",
			"\taX^2+bX+c=0の解を求める",
			"\t出力はこんな感じ",
			"\tif(x1 == DBL_MIN)cout<<\"解なし\"<<endl;",
			"\telse if(x1==DBL_MAX)cout<<\"不定\"<<endl;",
			"\telse if(!i)cout<<x1<<\" , \"<<x2<<endl;",
			"\telse cout<<x1<<\" +- \"<<x2<<\"i\"<<endl;",
			"*/",
			"double x1, x2;",
			"bool i = false;",
			"void quadeq(double a, double b, double c){",
			"\tdouble d, x;",
			"\tif(a != 0){",
			"\t\tb /= a; c /= a;",
			"\t\tif(c != 0){",
			"\t\t\tb /= 2;",
			"\t\t\td = b*b - c;",
			"\t\t\tif(d > 0){",
			"\t\t\t\tif(b > 0) x = -b - sqrt(d);",
			"\t\t\t\telse x = -b + sqrt(d);",
			"\t\t\t\tx1 = x; x2 = c/x;",
			"\t\t\t}else if(d < 0){",
			"\t\t\t\tx1 = -b; x2 = sqrt(-d); i = true;",
			"\t\t\t}else{",
			"\t\t\t\tx1 = x2 = -b;",
			"\t\t\t}",
			"\t\t}else{",
			"\t\t\tx1 = -b; x2 = 0;",
			"\t\t}",
			"\t}else if(b != 0){",
			"\t\tx1 = x2 = -c/b;",
			"\t}",
			"\telse if(c != 0) x1 = x2 = DBL_MIN;",
			"\telse x1 = x2 = DBL_MAX;",
			"}"
		],
		"description": "二次方程式の解を求める"
	},
	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"// vector vの中のn以下の数で最大のものを返す",
			"int bs(vector<ll> &v, ll x){",
			"\tint ok = -1; //これがx以下 ",
			"\tint ng = v.size(); //x以上 ",
			"\t// 問題によってokとngを入れ替える",
			"\twhile(abs(ok - ng) > 1){",
			"\t\tint mid = (ok + ng)/2;",
			"\t\tif(v[mid] <= x) ok = mid;",
			"\t\telse ng = mid;",
			"\t}",
			"\treturn ok;",
			"}"
		],
		"description": "二分探索"
	},
	"yakusu_enum": {
		"prefix": "yakusu_enum",
		"body": [
			"vector<ll> enum_div(ll n) {",
			"\tvector<ll> ret;",
			"\tfor(ll i = 1 ; i*i <= n ; ++i){",
			"\t\tif(n%i == 0) {",
			"\t\t\tret.push_back(i);",
			"\t\t\tif(i != 1 && i*i != n){",
			"\t\t\t\tret.push_back(n/i);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}"
		],
		"description": "約数列挙"
	},
	"mnmod": {
		"prefix": "mnmod",
		"body": [
			"// xのn乗%modを計算",
			"ll mod_pow(ll x, ll n, ll mod = MOD) {",
			"\tll res = 1;",
			"\twhile(n > 0) {",
			"\t\tif(n & 1) res = res*x%mod;",
			"\t\tx = x*x%mod;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "mのn乗modPを計算"
	},
	"stringcount": {
		"prefix": "stringcount",
		"body": [
			"int stringcount(string s, char c) {",
			"\treturn count(s.cbegin(), s.cend(), c);",
			"}"
		],
		"description": "文字列中の特定の文字の個数をカウント"
	},
	"zip": {
		"prefix": "zip",
		"body": [
			"map<ll, ll> zip;",
			"int compress(vector<ll> x) {",
			"\tint unzip[x.size()];",
			"\tsort(x.begin(), x.end());",
			"\tx.erase(unique(x.begin(),x.end()),x.end());",
			"\tfor(int i = 0; i < x.size(); i++){",
			"\t\tzip[x[i]] = i;",
			"\t\tunzip[i] = x[i];",
			"\t}",
			"\treturn x.size();",
			"}"
		],
		"description": "一次元座標圧縮"
	},
	"modint": {
		"prefix": "modint",
		"body": [
			"struct mint {",
			"\tll x;",
			"\tmint(ll _x = 0) : x((_x % MOD + MOD) % MOD) {}",
			"",
			"\t/* 初期化子 */",
			"\tmint operator+() const { return mint(x); }",
			"\tmint operator-() const { return mint(-x); }",
			"",
			"\t/* 代入演算子 */",
			"\tmint& operator+=(const mint a) {",
			"\t\tif ((x += a.x) >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator-=(const mint a) {",
			"\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator*=(const mint a) {",
			"\t\t(x *= a.x) %= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator/=(const mint a) {",
			"\t\tx *= modinv(a).x;",
			"\t\tx %= MOD;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator%=(const mint a) {",
			"\t\tx %= a.x;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator++() {",
			"\t\t++x;",
			"\t\tif (x >= MOD) x -= MOD;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator--() {",
			"\t\tif (!x) x += MOD;",
			"\t\t--x;",
			"\t\treturn *this;",
			"\t}",
			"\tmint& operator&=(const mint a) {",
			"\t\tx &= a.x;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator|=(const mint a) {",
			"\t\tx |= a.x;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator^=(const mint a) {",
			"\t\tx ^= a.x;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator<<=(const mint a) {",
			"\t\tx *= pow(2, a).x;",
			"\t\treturn (*this);",
			"\t}",
			"\tmint& operator>>=(const mint a) {",
			"\t\tx /= pow(2, a).x;",
			"\t\treturn (*this);",
			"\t}",
			"",
			"\t/* 算術演算子 */",
			"\tmint operator+(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res += a;",
			"\t}",
			"\tmint operator-(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res -= a;",
			"\t}",
			"\tmint operator*(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res *= a;",
			"\t}",
			"\tmint operator/(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res /= a;",
			"\t}",
			"\tmint operator%(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res %= a;",
			"\t}",
			"\tmint operator&(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res &= a;",
			"\t}",
			"\tmint operator|(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res |= a;",
			"\t}",
			"\tmint operator^(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res ^= a;",
			"\t}",
			"\tmint operator<<(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res <<= a;",
			"\t}",
			"\tmint operator>>(const mint a) const {",
			"\t\tmint res(*this);",
			"\t\treturn res >>= a;",
			"\t}",
			"",
			"\t/* 条件演算子 */",
			"\tbool operator==(const mint a) const noexcept { return x == a.x; }",
			"\tbool operator!=(const mint a) const noexcept { return x != a.x; }",
			"\tbool operator<(const mint a) const noexcept { return x < a.x; }",
			"\tbool operator>(const mint a) const noexcept { return x > a.x; }",
			"\tbool operator<=(const mint a) const noexcept { return x <= a.x; }",
			"\tbool operator>=(const mint a) const noexcept { return x >= a.x; }",
			"",
			"\t/* ストリーム挿入演算子 */",
			"\tfriend istream& operator>>(istream& is, mint& m) {",
			"\t\tis >> m.x;",
			"\t\tm.x = (m.x % MOD + MOD) % MOD;",
			"\t\treturn is;",
			"\t}",
			"\tfriend ostream& operator<<(ostream& os, const mint& m) {",
			"\t\tos << m.x;",
			"\t\treturn os;",
			"\t}",
			"",
			"\t/* その他の関数 */",
			"\tmint modinv(mint a) { return pow(a, MOD - 2); }",
			"\tmint pow(mint x, mint n) {",
			"\t\tmint res = 1;",
			"\t\twhile (n.x > 0) {",
			"\t\t\tif ((n % 2).x) res *= x;",
			"\t\t\tx *= x;",
			"\t\t\tn.x /= 2;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		],
		"description": "ModInt"
	},
	"knapsack": {
		"prefix": "knapsack",
		"body": [
			"int knapsack(int n, int W, vi w, vi v) {",
			"\tvvi dp(n + 1, vi (W + 1, 0));",
			"\tfor(int i = 1; i <= n; i++) {",
			"\t\tfor(int j = 1; j <= W; j++) {",
			"\t\t\tif(j - w[i] >= 0) {",
			"\t\t\t\tchmax(dp[i][j], dp[i - 1][j - w[i]] + v[i]);",
			"\t\t\t}",
			"\t\t\tchmax(dp[i][j], dp[i - 1][j]);",
			"\t\t}",
			"\t}",
			"\treturn dp[n][W];",
			"}"
		],
		"description": "ナップサック問題"
	},
	"lcs": {
		"prefix": "lcs",
		"body": [
			"string lcs(string s, string t) {",
			"\tvvi dp(s.size() + 1, vi(t.size() + 1));",
			"\t",
			"\tfor(int i = 0; i < s.size(); i++) {//LCS",
			"\t\tfor(int j = 0; j < t.size(); j++) {",
			"\t\t\tif(s[i] == t[j]) {",
			"\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;",
			"\t\t\t}",
			"\t\t\telse{",
			"\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\t// 復元",
			"\tstring ans = \"\";",
			"\tint i = (int)s.size(), j = (int)t.size();",
			"\twhile (i > 0 && j > 0){",
			"\t\t// (i-1, j) -> (i, j) と更新されていた場合",
			"\t\tif (dp[i][j] == dp[i-1][j]) {",
			"\t\t\t--i; // DP の遷移を遡る",
			"\t\t}",
			"\t\t// (i, j-1) -> (i, j) と更新されていた場合",
			"\t\telse if (dp[i][j] == dp[i][j-1]) {",
			"\t\t\t--j; // DP の遷移を遡る",
			"\t\t}",
			"\t\t// (i-1, j-1) -> (i, j) と更新されていた場合",
			"\t\telse {",
			"\t\t\tans = s[i-1] + ans;",
			"\t\t\t--i, --j; // DP の遷移を遡る",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description": "最長共通部分列問題を解く"
	},
	"icpctemplate": {
		"prefix": "icpctemplate",
		"body": [
			"#include <iostream>",
			"#include <algorithm>",
			"#include <string>",
			"#include <vector>",
			"using namespace std;",
			"typedef long long int ll;",
			"typedef vector<int> vi;",
			"#define rep(i,n) for(int i = 0; i < (n); ++i)",
			"int main(void){}"
		],
		"description": "ICPCテンプレート"
	},
	"gpriority_queue": {
		"prefix": "gpriority_queue",
		"body": [
			"priority_queue<int, vector<int>, greater<int> > queue;"
		],
		"description": "int型一次元で昇順に取り出せるのpriority_queue"
	},
	"bellman_ford": {
		"prefix": "bellman_ford",
		"body": [
			"// 頂点fromから頂点toへのコストcostの辺",
			"struct bf_edge {",
			"\tint from;",
			"\tint to;",
			"\tint cost;",
			"};",
			"",
			"class Bellman_Ford{",
			"public:",
			"\tvector<bf_edge> es; // 辺",
			"\tvector<int> d; // d[i]...頂点sから頂点iまでの最短距離",
			"\tint V, E; // Vは頂点数、Eは辺数",
			"",
			"\tBellman_Ford(int v, int e) {",
			"\t\tV = v;",
			"\t\tE = e;",
			"\t\td = vector<int>(v);",
			"\t}",
			"",
			"\tvoid add(int from, int to, int cost) {",
			"\t\tbf_edge ed = {from, to, cost};",
			"\t\tes.push_back(ed);",
			"\t}",
			"",
			"\t// s番目の頂点から各頂点への最短距離を求める",
			"\t// trueなら負の閉路が存在する",
			"\tbool shortest_path(int s) {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\td[i] = 0;",
			"\t\t}",
			"\t\tfor (int i = 0; i < 3*V; i++) {",
			"\t\t\tfor(int j = 0; j < E; j++) {",
			"\t\t\t\tbf_edge e = es[j];",
			"\t\t\t\tif(d[e.to] > d[e.from] + e.cost) {",
			"\t\t\t\t\td[e.to] = d[e.from] + e.cost;",
			"",
			"\t\t\t\t\t// 3n回目にも更新があるなら負の閉路が存在する",
			"\t\t\t\t\tif(i == V - 1)return true;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn false;",
			"\t}",
			"};"
		],
		"description": "ベルマンフォード法"
	},
	"topological_sort": {
		"prefix": "topological_sort",
		"body": [
			"vvi G(1000); // グラフ(リスト)",
			"",
			"// トポロジカルソート",
			"void rec(int v, vector<bool> &seen, vector<int> &order) {",
			"\tseen[v] = true;",
			"\tfor (int i= 0; i < G[v].size(); i++) {",
			"\t\tint next = G[v][i];",
			"\t\tif (seen[next]) continue; // 既に訪問済みなら探索しない",
			"\t\trec(next, seen, order);",
			"\t}",
			"\torder.push_back(v);",
			"}",
			"",
			"vector<int> topo(int N) { // Nはノード数",
			"\t// 探索",
			"\tvector<bool> seen(N, 0); // 初期状態では全ノードが未訪問",
			"\tvector<int> order; // トポロジカルソート順",
			"\tfor (int v = 0; v < N; ++v) {",
			"\t\tif (seen[v]) continue; // 既に訪問済みなら探索しない",
			"\t\trec(v, seen, order);",
			"\t}",
			"\treverse(order.begin(), order.end());",
			"\treturn order;",
			"}"
		],
		"description": "トポロジカルソート"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"class DIJKSTRA {",
			"public:",
			"\tint V;",
			"",
			"\tstruct dk_edge {",
			"\t\tint to;",
			"\t\tll cost;",
			"\t};",
			"",
			"\ttypedef pair<ll, int> PI;  // firstは最短距離、secondは頂点の番号",
			"\tvector<vector<dk_edge> > G;",
			"\tvector<ll> d;      //これ答え。d[i]:=V[i]までの最短距離",
			"\tvector<int> prev;  //経路復元",
			"",
			"\tDIJKSTRA(int size) {",
			"\t\tV = size;",
			"\t\tG = vector<vector<dk_edge> >(V);",
			"\t\tprev = vector<int>(V, -1);",
			"\t}",
			"",
			"\tvoid add(int from, int to, ll cost) {",
			"\t\tdk_edge e = {to, cost};",
			"\t\tG[from].push_back(e);",
			"\t}",
			"",
			"\tvoid dijkstra(int s) {",
			"\t\t// greater<P>を指定することでfirstが小さい順に取り出せるようにする",
			"\t\tpriority_queue<PI, vector<PI>, greater<PI> > que;",
			"\t\td = vector<ll>(V, LLINF);",
			"\t\td[s] = 0;",
			"\t\tque.push(PI(0, s));",
			"",
			"\t\twhile (!que.empty()) {",
			"\t\t\tPI p = que.top();",
			"\t\t\tque.pop();",
			"\t\t\tint v = p.second;",
			"\t\t\tif (d[v] < p.first) continue;",
			"\t\t\tfor (int i = 0; i < G[v].size(); i++) {",
			"\t\t\t\tdk_edge e = G[v][i];",
			"\t\t\t\tif (d[e.to] > d[v] + e.cost) {",
			"\t\t\t\t\td[e.to] = d[v] + e.cost;",
			"\t\t\t\t\tprev[e.to] = v;",
			"\t\t\t\t\tque.push(PI(d[e.to], e.to));",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tvector<int> get_path(int t) {",
			"\t\tvector<int> path;",
			"\t\tfor (; t != -1; t = prev[t]) {",
			"\t\t\t// tがsになるまでprev[t]をたどっていく",
			"\t\t\tpath.push_back(t);",
			"\t\t}",
			"\t\t//このままだとt->sの順になっているので逆順にする",
			"\t\treverse(path.begin(), path.end());",
			"\t\treturn path;",
			"\t}",
			"\tvoid show(void) {",
			"\t\tfor (int i = 0; i < d.size() - 1; i++) {",
			"\t\t\tcout << d[i] << \" \";",
			"\t\t}",
			"\t\tcout << d[d.size() - 1] << endl;",
			"\t}",
			"};"
		],
		"description": "ダイクストラ法"
	},
	"warshall_floyd": {
		"prefix": "warshall_floyd",
		"body": [
			"template <typename T>",
			"class WAR_FLY {",
			"public:",
			"\tvector<vector<T>> d; // 辺の数",
			"\tint V; // 頂点の数",
			"\t",
			"\tWAR_FLY(int n) {",
			"\t\tV = n;",
			"\t\td = vector<vector<T> > (n,vector<T>(n));",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tfor(int j = 0; j < V; j++) {",
			"\t\t\t\tif(i == j) {",
			"\t\t\t\t\td[i][j] = 0;",
			"\t\t\t\t}",
			"\t\t\t\telse {",
			"\t\t\t\t\td[i][j] = LLINF;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid warshall_floyd(void) {",
			"\t\tfor(int k = 0; k < V; k++) {",
			"\t\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\t\tfor(int j = 0; j < V; j++) {",
			"\t\t\t\t\td[i][j] = min((ll)d[i][j], (ll)d[i][k] + (ll)d[k][j]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid add(int from, int to, T cost) {",
			"\t\td[from][to] = cost;",
			"\t}",
			"",
			"\tbool is_negative_loop(void) {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tif(d[i][i] < 0) return true;",
			"\t\t}",
			"\t\treturn false;",
			"\t}",
			"",
			"\tvoid show(void) {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tfor(int j = 0; j < V; j++) {",
			"\t\t\t\tcout << d[i][j] << \" \";",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "ワーシャルフロイド法"
	},
	"intersect": {
		"prefix": "intersect",
		"body": [
			"void intersect(set<int> &Set_A, set<int> &Set_B, set<int> &Set_res) {",
			"\tset_intersection(Set_A.begin(), Set_A.end(), Set_B.begin(), Set_B.end(), inserter(Set_res, Set_res.end()));",
			"}"
		],
		"description": "setのintersect"
	},
	"digitsum": {
		"prefix": "digitsum",
		"body": [
			"int digsum(int n) {",
			"\tint res = 0;",
			"\twhile(n > 0) {",
			"\t\tres += n%10;",
			"\t\tn /= 10;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "桁和"
	},
	"indexdintance": {
		"prefix": "indexdistance",
		"body": [
			"int indexdistance(vector<int> distance_array, char c) {",
			"\treturn static_cast<int>(std::distance(std::begin(distance_array), std::find(std::begin(distance_array), std::end(distance_array), c)));",
			"}"
		],
		"description": "特定の文字の配列内の添字"
	},
	"gyakugen": {
		"prefix": "gyakugen",
		"body": [
			"// (a/b)%P の場合は，(a%P)*modinv(b)%P とする",
			"ll modinv(ll a) {",
			"\tll b = MOD, u = 1, v = 0;",
			"\twhile (b) {",
			"\t\tll t = a / b;",
			"\t\ta -= t * b; swap(a, b);",
			"\t\tu -= t * v; swap(u, v);",
			"\t}",
			"\tu %= MOD;",
			"\tif (u < 0) u += MOD;",
			"\treturn u;",
			"}"
		],
		"description": "逆元の計算"
	},
	"BoyerMoore": {
		"prefix": "BoyerMoore",
		"body": [
			"class BoyerMoore {",
			"\tpublic:",
			"\tstring text;",
			"\tstring pattern;",
			"\tint n;",
			"\tint m;",
			"\tmap<char, int> lambda;",
			"\tBoyerMoore(string text_, string pattern_) : ",
			"\t\ttext(text_), pattern(pattern_), n(text_.size()), m(pattern_.size()) {",
			"\t\tcompute_lambda();",
			"\t};",
			"\tvoid compute_lambda(void) {",
			"\t\tfor(int j = 1; j <= m; j++) {",
			"\t\t\tlambda[pattern.at(j - 1)] = j;",
			"\t\t}",
			"\t};",
			"\tint get_lambda(const char& c) {",
			"\t\tif (lambda.find(c) != lambda.end()) {",
			"\t\t\treturn lambda[c];",
			"\t\t} else {",
			"\t\t\treturn 0;",
			"\t\t}",
			"\t};",
			"\tbool match(void) {",
			"\t\tint s = 0;",
			"\t\twhile(s <= n - m) {",
			"\t\t\tint j = m;",
			"\t\t\twhile(j > 0 && pattern.at(j - 1) == text.at(s + j - 1)) {",
			"\t\t\t\tj--;",
			"\t\t\t}",
			"\t\t\tif(j == 0) {",
			"\t\t\t\treturn true;//ここを消すとsが文字列の位置を示す",
			"\t\t\t\ts++;",
			"\t\t\t} else {",
			"\t\t\t\ts += std::max(1, j - get_lambda(text.at(s + j - 1)));",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn false;",
			"\t};",
			"};"
		],
		"description": "BoyerMoore法"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"UnionFind uni(100);",
			"// Union-Findも呼んで！！そして上の書き換えて！！！",
			"struct kr_edge {",
			"\tint u; // 辺の片方，fromではないので二回辺を張る必要はない",
			"\tint v; // 辺のもう片方",
			"\tint cost;",
			"",
			"\t// コストの大小で順序定義",
			"\tbool operator<(const kr_edge& e) const {",
			"\t\treturn cost < e.cost;",
			"\t}",
			"};",
			"class Kruskal{",
			"\tpublic:",
			"",
			"\tbool comp(const kr_edge& e1, const kr_edge& e2) { // sort関数の比較関数",
			"\t\treturn e1.cost < e2.cost;",
			"\t}",
			"",
			"\tvector<kr_edge> es; // 辺の集合",
			"\tvector<kr_edge> minst; // 最小全域木に用いられる辺の集合",
			"\tint V, E; // 頂点数と辺数",
			"",
			"\tKruskal(int v) {",
			"\t\tV = v;",
			"\t}",
			"",
			"\tvoid add(int v, int u, int cost){",
			"\t\tkr_edge e = {v, u, cost};",
			"\t\tes.push_back(e);",
			"\t}",
			"",
			"\tint kruskal(void) {",
			"\t\tsort(es.begin(), es.end()); // kr_edge.costが小さい順にソートされる",
			"\t\tUnionFind uni(V); //union-findの初期化",
			"\t\tint res = 0;",
			"\t\tfor(int i = 0; i < es.size(); i++) {",
			"\t\t\tkr_edge e = es[i];",
			"\t\t\tif(uni.root(e.u) != uni.root(e.v)) {",
			"\t\t\t\tuni.connect(e.u, e.v);",
			"\t\t\t\tres += e.cost;",
			"\t\t\t\tminst.push_back(e);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"",
			"\tvoid show(void) {",
			"\t\tvvi v(V, vi(V, -1));",
			"\t\tfor(int i = 0; i < minst.size(); i++) {",
			"\t\t\tv[minst[i].u][minst[i].v] = minst[i].cost;",
			"\t\t\tv[minst[i].v][minst[i].u] = minst[i].cost;",
			"\t\t}",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tfor(int j = 0; j < V; j++) {",
			"\t\t\t\tif(v[i][j] == -1) {",
			"\t\t\t\t\tprintf(\"  __ \");",
			"\t\t\t\t} else {",
			"\t\t\t\t\tprintf(\"%4d \", v[i][j]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "クラスカル法"
	},
	"hutei": {
		"prefix": "hutei",
		"body": [
			"void hutei(int a, int b, int c, bool minus) {",
			"\tvector<int> arr;",
			"",
			"\t// A / B = div...mod",
			"\tint A = max(a, b);",
			"\tint B = min(a, b);",
			"\tint div, mod;",
			"",
			"\twhile(1) {",
			"\t\tdiv = A/B;",
			"\t\tmod = A%B;",
			"\t\tarr.push_back(div);",
			"",
			"\t\tA = B;",
			"\t\tB = mod;",
			"",
			"\t\tif(mod == 1) {",
			"\t\t\tbreak;",
			"\t\t}",
			"\t}",
			"",
			"\tvector<vector<int> > calc(2, vector<int> (arr.size() + 1, INF));",
			"",
			"\tfor(int i = 0; i < arr.size() - 1; i++) {",
			"\t\tcalc[0][i] = -arr[i];",
			"\t}",
			"\tcalc[1][arr.size() - 1] = -arr[arr.size() - 1];",
			"\tcalc[1][arr.size()] = 1;",
			"",
			"\tfor(int i = arr.size()-2; i >= 0; i--) {",
			"\t\tcalc[1][i] = calc[0][i]*calc[1][i + 1] + calc[1][i + 2];",
			"\t}",
			"",
			"\tint x = calc[1][0]*c;",
			"\tint y = calc[1][1]*c;",
			"",
			"\tif(minus) {",
			"\t\ty *= -1;",
			"\t}",
			"\tcout << a << \"(\" << b << \"m + \" << x << \")\";",
			"\tif(minus) {",
			"\t\tcout << \" - \";",
			"\t} else {",
			"\t\tcout << \" + \";",
			"\t}",
			"\tcout << b << \"(\" << a << \"m + \" << y << \")\" << \" = \" << c << endl;",
			"}"
		],
		"description": "不定方程式を解く"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"template <typename T>",
			"class Sum {",
			"public:",
			"\t// 単位元",
			"\tT unit;",
			"",
			"\tSum(void) {",
			"\t\t// 単位元",
			"\t\tunit = 0;",
			"\t}",
			"",
			"\t// 演算関数",
			"\tT calc(T a, T b) { return a + b; }",
			"};",
			"",
			"template <typename T>",
			"struct Min {",
			"public:",
			"\t// 単位元",
			"\tT unit;",
			"",
			"\tMin(void) {",
			"\t\t// 単位元",
			"\t\tunit = INF;",
			"\t}",
			"",
			"\t// 演算関数",
			"\tT calc(T a, T b) { return min(a, b); }",
			"};",
			"",
			"template <typename T, class MONOID>",
			"class SegmentTree {",
			"public:",
			"\t// セグメント木の葉の要素数",
			"\tint n;",
			"",
			"\t// セグメント木",
			"\tvector<T> tree;",
			"",
			"\t// モノイド",
			"\tMONOID mono;",
			"",
			"\tSegmentTree(vector<T>& v)",
			"\t\t: n(1 << (int)ceil(log2(v.size()))),",
			"\t\ttree(vector<T>(n << 1, mono.unit)) {",
			"\t\tfor (int i = 0; i < v.size(); ++i) {",
			"\t\t\ttree[i + n] = v[i];",
			"\t\t}",
			"\t\tfor (int i = n - 1; i > 0; --i) {",
			"\t\t\ttree[i] = mono.calc(tree[i << 1 | 0], tree[i << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\tSegmentTree(int _n)",
			"\t\t: n(1 << (int)ceil(log2(_n))), tree(vector<T>(n << 1, mono.unit)) {}",
			"",
			"\t// k番目の値(0-indexed)をxに変更",
			"\tvoid update(int k, T x) {",
			"\t\tk += n;",
			"\t\ttree[k] = x;",
			"\t\tfor (k = k >> 1; k > 0; k >>= 1) {",
			"\t\t\ttree[k] = mono.calc(tree[k << 1 | 0], tree[k << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\t// k番目の値(0-indexed)をxを加算",
			"\tvoid add(int k, T x) {",
			"\t\tk += n;",
			"\t\ttree[k] += x;",
			"\t\tfor (k = k >> 1; k > 0; k >>= 1) {",
			"\t\t\ttree[k] = mono.calc(tree[k << 1 | 0], tree[k << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\t// [l, r)の最小値(0-indexed)を求める．",
			"\tT query(int l, int r) {",
			"\t\tT res = mono.unit;",
			"\t\tl += n;",
			"\t\tr += n;",
			"\t\twhile (l < r) {",
			"\t\t\tif (l & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[l++]);",
			"\t\t\t}",
			"\t\t\tif (r & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[--r]);",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"",
			"\tT operator[](int k) {",
			"\t\t// st[i]で添字iの要素の値を返す",
			"\t\tif (k - n >= 0 || k < 0) {",
			"\t\t\treturn -INF;",
			"\t\t}",
			"\t\treturn tree[tree.size() - n + k];",
			"\t}",
			"",
			"\tvoid show(int elements = 31) {",
			"\t\tint ret = 2;",
			"\t\tfor (int i = 1; i < max(2 * n, elements); ++i) {",
			"\t\t\tif (tree[i] == mono.unit)",
			"\t\t\t\tcout << \"UNIT \";",
			"\t\t\telse",
			"\t\t\t\tcout << tree[i] << \" \";",
			"\t\t\tif (i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "セグメント木"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"int lis(vi& v) {",
			"\tvi dp(1, v[0]);",
			"\tfor(int i = 1; i < v.size(); i++) {",
			"\t\tif(v[i] > dp[dp.size() - 1]) {",
			"\t\t\tdp.push_back(v[i]);",
			"\t\t} else {",
			"\t\t\tint pos = distance(dp.begin(), lower_bound(dp.begin(), dp.end(), v[i]));",
			"\t\t\tdp[pos] = v[i];",
			"\t\t}",
			"\t}",
			"\treturn dp.size();",
			"}"
		],
		"description": "LIS(最長増加部分列)"
	},
	"conlis": {
		"prefix": "conlis",
		"body": [
			"int conlis(vector<int>& v) {",
			"\tvi dp(v.size() + 1, 0);",
			"\tint ans = 0;",
			"\tfor(int i = 0; i < v.size(); i++) {",
			"\t\tdp[v[i]] = dp[v[i] - 1] + 1;",
			"\t\tans = max(ans, dp[v[i]]);",
			"\t}",
			"\treturn ans;",
			"}"
		],
		"description": "Continue LIS(最長連続増加部分列)"
	},
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"// x,y に ax + by = gcd(a, b) を満たす値が格納される",
			"// 返り値は<gcd(a, b), x, y>",
			"// auto [g, x, y] = extgcd(a, b);のように呼び出す",
			"tuple<ll, ll, ll> extgcd(ll a, ll b) {",
			"\tif (b == 0) {",
			"\t\treturn {a, 1, 0};",
			"\t}",
			"\tauto [g, x, y] = extgcd(b, a % b);",
			"\treturn {g, y, x - a / b * y};",
			"}"
		],
		"description": "拡張ユークリッドの互助法"
	},
	"StronglyConnectedComponent": {
		"prefix": "StronglyConnectedComponent",
		"body": [
			"class StronglyConnectedComponent {",
			"public:",
			"\tint V;          // 頂点数",
			"\tint SubGraph;   // 強連結成分の数",
			"\tvvi Graph;      // グラフの隣接リスト表現",
			"\tvvi revGraph;   // 辺の向きを逆にしたグラフ",
			"\tvvi SmallGraph; // 強連結成分分解によって縮めたグラフ",
			"\tvi dfsline;     // 帰りがけ順の並び",
			"\tvi compo;       // cmp[i]で頂点iの属するグループ",
			"\tvb used;        // すでに調べたか",
			"",
			"\tStronglyConnectedComponent(int v) {",
			"\t\tV = v;",
			"\t\tGraph = vvi(v);",
			"\t\trevGraph = vvi(v);",
			"\t\tused = vb(v);",
			"\t\tcompo = vi(v);",
			"\t}",
			"",
			"\tint operator[](int k) {",
			"\t\t// scc[i]でi番目の頂点のグループ番号を返す",
			"\t\treturn compo[k];",
			"\t}",
			"",
			"\tvoid add_edge(int from, int to) {",
			"\t\tGraph[from].push_back(to);",
			"\t\trevGraph[to].push_back(from);",
			"\t}",
			"",
			"\tvoid dfs(int v) {",
			"\t\tused[v] = true;",
			"\t\tfor(int i = 0; i < Graph[v].size(); i++) {",
			"\t\t\tif(!used[Graph[v][i]]) dfs(Graph[v][i]);",
			"\t\t}",
			"\t\tdfsline.push_back(v);",
			"\t}",
			"",
			"\tvoid revdfs(int v, int k) {",
			"\t\tused[v] = true;",
			"\t\tcompo[v] = k;",
			"\t\tfor(int i = 0; i < revGraph[v].size(); i++) {",
			"\t\t\tif(!used[revGraph[v][i]]) revdfs(revGraph[v][i], k);",
			"\t\t}",
			"\t}",
			"",
			"\tint scc(void) {",
			"\t\tused = vb((int)used.size(), false);",
			"\t\tdfsline.clear();",
			"\t\tfor(int v = 0; v < V; v++) {",
			"\t\t\tif(!used[v]) dfs(v);",
			"\t\t}",
			"\t\tused = vb(used.size(), false);",
			"\t\tSubGraph = 0;",
			"\t\tfor(int i = dfsline.size() - 1; i >= 0; i--) {",
			"\t\t\tif(!used[dfsline[i]]) revdfs(dfsline[i], SubGraph++);",
			"\t\t}",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tcompo[i] = SubGraph - compo[i] - 1;",
			"\t\t}",
			"\t\treturn SubGraph;",
			"\t}",
			"",
			"\tvoid build(void) {",
			"\t\t// 縮めたグラフを構築する",
			"\t\tSmallGraph = vvi(SubGraph);",
			"\t\tfor (int i = 0; i < Graph.size(); i++) {",
			"\t\t\tfor(int j = 0; j < Graph[i].size(); j++) {",
			"\t\t\t\tint to = Graph[i][j];",
			"\t\t\t\tint s = compo[i], t = compo[to];",
			"\t\t\t\tif (s != t){",
			"\t\t\t\t\tSmallGraph[s].push_back(t);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\t// 被った辺を削除",
			"\t\t\tSmallGraph[i].erase(unique(SmallGraph[i].begin(), SmallGraph[i].end()), SmallGraph[i].end());",
			"\t\t}",
			"\t}",
			"",
			"\tvoid show_set_to_edge(void) {",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"集合\" << i << \"から出ている辺 : \";",
			"\t\t\tfor(int j = 0; j < SmallGraph[i].size(); j++) {",
			"\t\t\t\tcout << SmallGraph[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_group_of_node(void) {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tcout << \"頂点\" << i << \"の属するグループ : \" << compo[i] << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_node_in_group(void) {",
			"\t\tvvi group(SubGraph);",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tgroup[compo[i]].push_back(i);",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"グループ\" << i << \"に属する頂点 : \";",
			"\t\t\tfor(int j = 0; j < group[i].size(); j++) {",
			"\t\t\t\tcout << group[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "強連結成分分解"
	},
	"CoordinateCompression": {
		"prefix": "CoordinateCompression",
		"body": [
			"class Compress {",
			"public:",
			"\tint before_W, before_H, N;",
			"\tvi before_X1, before_X2, before_Y1, before_Y2;",
			"\tint after_W, after_H;",
			"\tvi after_X1, after_X2, after_Y1, after_Y2;",
			"\t",
			"\t// (x1,y1) -> (x2, y2) の直線上のマスが塗られているとする",
			"\t// 点の場合は (x1,y1) == (x2, y2) とする",
			"\t// 四角形の場合は直線の集合とする",
			"\tCompress(int max_h, int max_w, int n, vi x1, vi x2, vi y1, vi y2) {",
			"\t\tbefore_H = max_h;",
			"\t\tbefore_W = max_w;",
			"\t\tN = n;",
			"\t\tbefore_X1 = x1;",
			"\t\tbefore_X2 = x2;",
			"\t\tbefore_Y1 = y1;",
			"\t\tbefore_Y2 = y2;",
			"\t\tafter_X1 = vi(max_w);",
			"\t\tafter_X2 = vi(max_w);",
			"\t\tafter_Y1 = vi(max_h);",
			"\t\tafter_Y2 = vi(max_h);",
			"\t}",
			"",
			"\tvoid compress(void) {",
			"\t\tafter_W = exec_compress(before_X1, before_X2, after_X1, after_X2, before_W, \"width\");",
			"\t\tafter_H = exec_compress(before_Y1, before_Y2, after_Y1, after_Y2, before_H, \"height\");",
			"\t}",
			"",
			"\tvoid before_show(void) {",
			"\t\tvvc v(before_H, vc(before_W, '_'));",
			"\t\tcout << \"H = \" << before_H << \", W = \" << before_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = before_Y1[i]; y <= before_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = before_X1[i]; x <= before_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, before_H){",
			"\t\t\trep(j, before_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid after_show(void) {",
			"\t\tvvc v(after_H, vc(after_W, '_'));",
			"\t\tcout << \"H = \" << after_H << \", W = \" << after_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = after_Y1[i]; y <= after_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = after_X1[i]; x <= after_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, after_H){",
			"\t\t\trep(j, after_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"private:",
			"\tint exec_compress(vi &z1, vi &z2, vi &aft_z1, vi &aft_z2, int max_len, string mode) {",
			"\t\tvector<int> zs;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tif(z1[i] > z2[i]) swap(z1[i], z2[i]);",
			"",
			"\t\t\tzs.push_back(z1[i]);",
			"\t\t\tzs.push_back(z2[i]);",
			"",
			"\t\t\tif(mode == \"width\") {",
			"\t\t\t\tif(z2[i] + 1 <= max_len) zs.push_back(z2[i] + 1);",
			"\t\t\t} else if(mode == \"height\") {",
			"\t\t\t\tif(0 < z1[i] - 1) zs.push_back(z1[i] - 1);",
			"\t\t\t}",
			"\t\t}",
			"\t\tzs.push_back(1);",
			"\t\tzs.push_back(max_len);",
			"",
			"\t\tsort(zs.begin(), zs.end());",
			"\t\tzs.erase(unique(zs.begin(), zs.end()), zs.end());",
			"",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\taft_z1[i] = find(zs.begin(), zs.end(), z1[i]) - zs.begin() + 1;",
			"\t\t\taft_z2[i] = find(zs.begin(), zs.end(), z2[i]) - zs.begin() + 1;",
			"\t\t}",
			"\t\treturn zs.size();",
			"\t}",
			"};"
		],
		"description": "二次元座標圧縮"
	},
	"template": {
		"prefix": "templete",
		"body": [
			"#include <iostream>",
			"#include <cstdio>",
			"#include <algorithm>",
			"#include <cmath>",
			"#include <vector>",
			"#include <list>",
			"#include <set>",
			"#include <map>",
			"#include <queue>",
			"#include <stack>",
			"#include <cctype>",
			"#include <cassert>",
			"#include <climits>",
			"#include <string>",
			"#include <bitset>",
			"#include <cfloat>",
			"#include <random>",
			"#include <iomanip>",
			"#include <unordered_set>",
			"using namespace std;",
			"typedef long double ld;",
			"typedef long long int ll;",
			"typedef unsigned long long int ull;",
			"typedef vector<int> vi;",
			"typedef vector<char> vc;",
			"typedef vector<bool> vb;",
			"typedef vector<double> vd;",
			"typedef vector<string> vs;",
			"typedef vector<ll> vll;",
			"typedef vector<pair<int,int> > vpii;",
			"typedef vector<pair<ll,ll> > vpll;",
			"typedef vector<vi> vvi;",
			"typedef vector<vvi> vvvi;",
			"typedef vector<vc> vvc;",
			"typedef vector<vs> vvs;",
			"typedef vector<vll> vvll;",
			"typedef map<int,int> mii;",
			"typedef set<int> si;",
			"#define rep(i,n) for(int i = 0; i < (n); ++i)",
			"#define rrep(i,n) for(int i = 1; i <= (n); ++i)",
			"#define arep(i,v) for(auto i : v)",
			"#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)",
			"#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)",
			"#define fin(ans) cout << (ans) << '\n'",
			"#define STLL(s) strtoll(s.c_str(), NULL, 10)",
			"#define mp(p,q) make_pair(p, q)",
			"#define pb(n) push_back(n)",
			"#define all(a) a.begin(), a.end()",
			"#define rall(a) a.rbegin(), a.rend()",
			"#define Sort(a) sort(a.begin(), a.end())",
			"#define Rort(a) sort(a.rbegin(), a.rend())",
			"#define MATHPI acos(-1)",
			"#define fi first",
			"#define se second",
			"constexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};",
			"constexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};",
			"template <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}",
			"template <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}",
			"template <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\n':' ');}}",
			"inline string getline(){string s; getline(cin,s); return s;}",
			"inline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}",
			"inline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}",
			"inline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}",
			"struct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};",
			"const int INF = INT_MAX;",
			"constexpr ll LLINF = 1LL<<60;",
			"constexpr ll MOD = 1000000007;",
			"constexpr double EPS = 1e-9;",
			"",
			"int main() {",
			"\t",
			"}"
		],
		"description": "テンプレート"
	},
	"combination": {
		"prefix": "combination",
		"body": [
			"#define MAX_NCK 201010",
			"ll f[MAX_NCK], rf[MAX_NCK];",
			"",
			"// modinvも呼ぶ！！",
			"",
			"bool isinit = false;",
			"",
			"void init(void) {",
			"\tf[0] = 1;",
			"\trf[0] = modinv(1);",
			"\tfor(int i = 1; i < MAX_NCK; i++) {",
			"\t\tf[i] = (f[i - 1] * i) % MOD;",
			"\t\trf[i] = modinv(f[i]);",
			"\t}",
			"}",
			"",
			"ll nCk(int n, int k) {",
			"\tif(!isinit) {",
			"\t\tinit();",
			"\t\tisinit = 1;",
			"\t}",
			"\tif(n < k) return 0;",
			"\tll nl = f[n]; // n!",
			"\tll nkl = rf[n - k]; // (n-k)!",
			"\tll kl = rf[k]; // k!",
			"\tll nkk = (nkl * kl) % MOD;",
			"",
			"\treturn (nl * nkk) % MOD;",
			"}"
		],
		"description": "組み合わせ・逆元でnCkを求める"
	},
	"kika": {
		"prefix": "kika",
		"body": [
			"/* ==== 幾何ライブラリ ==== */",
			"/* 点 */",
			"struct Point {",
			"\tdouble x;",
			"\tdouble y;",
			"\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}",
			"",
			"\t// === 四則演算の定義 ===",
			"\tfriend inline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}",
			"\tfriend inline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}",
			"\tfriend inline Point operator * (const Point &p, const double a) {return Point(p.x * a, p.y * a);}",
			"\tfriend inline Point operator * (const double a, const Point &p) {return Point(a * p.x, a * p.y);}",
			"\tfriend inline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}",
			"\tfriend inline Point operator / (const Point &p, const double a) {return Point(p.x / a, p.y / a);}",
			"",
			"\t// === その他の演算 ===",
			"\t// 反時計回りに90度回転",
			"\tfriend Point rot90(const Point &p) {return Point(-p.y, p.x);}",
			"",
			"\t// 直線b,cからみて，aがどちら側にいるか判定",
			"\t// 1: bを上cを下とした時にaが右側にある, -1: aが左側にある, 0: aは直線bc上",
			"\tfriend int simple_ccw(const Point &a, const Point &b, const Point &c) {",
			"\t\tif(OuterProduct(b-a, c-a) > EPS) return 1;",
			"\t\tif(OuterProduct(b-a, c-a) < -EPS) return -1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\t// 内積",
			"\tfriend inline double InnerProduct(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}",
			"\t// 外積",
			"\tfriend inline double OuterProduct(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}",
			"",
			"\t// 二次元のノーム(ユークリッド距離)を計算",
			"\tfriend inline double norm2(const Point &p) {return sqrt(InnerProduct(p, p));}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}",
			"};",
			"",
			"/* 線 */",
			"struct Line {",
			"\tvector<Point> line;",
			"",
			"\tLine(void) {}",
			"\t// 線分の時",
			"\tLine(Point a, Point b = Point(0.0, 0.0)) {",
			"\t\t// x座標が小さい方->y座標が小さい順にしておく",
			"\t\tif(a.x > b.x) {",
			"\t\t\tswap(a, b);",
			"\t\t} else if(a.x == b.x && a.y > b.y) {",
			"\t\t\tswap(a, b);",
			"\t\t}",
			"\t\tline.push_back(a);",
			"\t\tline.push_back(b);",
			"\t}",
			"\t// 多角形などの時",
			"\tLine(vector<Point> L) {",
			"\t\t/*",
			"\t\t// 基本はソートするとバグるのでしないこと",
			"\t\tsort(L.begin(), L.end(), [](Point const& lhs, Point const& rhs) {",
			"\t\t\tif(lhs.x != rhs.x) return lhs.x < rhs.x;",
			"\t\t\telse if(lhs.y != rhs.y) return lhs.y < rhs.y;",
			"\t\t\treturn true;",
			"\t\t});",
			"\t\t*/",
			"\t\tline = L;",
			"\t}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Line &l) {",
			"\t\ts << '{';",
			"\t\trep(i, l.line.size()) {",
			"\t\t\tif(i) {",
			"\t\t\t\ts << \", \";",
			"\t\t\t}",
			"\t\t\ts << l.line[i];",
			"\t\t}",
			"\t\ts << '}';",
			"\t\treturn s;",
			"\t}",
			"};",
			"",
			"/* 単位変換 */",
			"double torad(int deg) {return (double)(deg) * MATHPI / 180;}",
			"double todeg(double ang) {return ang * 180 / MATHPI;}",
			"",
			"/* 直線や多角形の交点 */",
			"Line crosspoint(const Line &L, const Line &M) {",
			"\tLine res;",
			"\tLine l = L;",
			"\tLine m = M;",
			"\tl.line.push_back(l.line[0]);",
			"\tm.line.push_back(m.line[0]);",
			"\tfor(int i = 0; i < l.line.size() - 1; i++) {",
			"\t\tfor(int j = 0; j < m.line.size() - 1; j++) {",
			"\t\t\tdouble d = OuterProduct(m.line[j + 1] - m.line[j], l.line[i + 1] - l.line[i]);",
			"\t\t\tif(abs(d) < EPS) continue;",
			"\t\t\tres.line.push_back(l.line[i] + (l.line[i + 1] - l.line[i]) * OuterProduct(m.line[j + 1] - m.line[j], m.line[j + 1] - l.line[i]) / d);",
			"\t\t}",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"/* 外心 */",
			"Point gaisin(const Point a, const Point b, const Point c) {",
			"\t// 外心は三角形の二つの辺の垂直二等分線の交点",
			"\tLine ab( (a + b)/2, (a + b)/2 + rot90(a - b) );",
			"\tLine bc( (b + c)/2, (b + c)/2 + rot90(b - c) );",
			"\treturn crosspoint(ab, bc).line[0];",
			"}",
			"",
			"/* 最小包含円 */",
			"double SmallestEnclosingCircle(const vector<Point> &V) {",
			"\tint N = V.size();",
			"\tif(N <= 1) return 0;",
			"",
			"\t// 最小包含円の中心の候補",
			"\tvector<Point> CenterCandidate;",
			"\tfor(int i = 0; i < N; i++) {",
			"\t\tfor(int j = i + 1; j < N; j++) {",
			"\t\t\t// 最小包含円の円弧上に点が２つしかないの時",
			"\t\t\tCenterCandidate.push_back( (V[i] + V[j]) / 2 );",
			"\t\t\tfor(int k = j + 1; k < N; k++) {",
			"\t\t\t\tif(!simple_ccw(V[i], V[j], V[k])) {",
			"\t\t\t\t\t// 三点が一直線上にある",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\t// 三点の外心が円の中心",
			"\t\t\t\tPoint r = gaisin(V[i], V[j], V[k]);",
			"\t\t\t\tCenterCandidate.push_back(r);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tdouble res = INF;",
			"\trep(c, CenterCandidate.size()) {",
			"\t\tdouble tmp = 0.0;",
			"\t\trep(v, V.size()) {",
			"\t\t\t// 中心からの距離が最大の点との距離が，包含円の半径になる",
			"\t\t\tchmax(tmp, norm2(V[v] - CenterCandidate[c]));",
			"\t\t}",
			"\t\t// 候補の包含円の中で，半径が最小の包含円が最小包含円になる．",
			"\t\tchmin(res, tmp);",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"// 直線a-bと点pの距離",
			"long double distance(const Point& p, const Point& a, const Point& b) {",
			"\tlong double A = b.y - a.y;",
			"\tlong double B = a.x - b.x;",
			"\tlong double C = a.y * b.x - b.y * a.x;",
			"\treturn abs(A * p.x + B * p.y + C) / sqrt(A * A + B * B);",
			"}"
		],
		"description": "幾何ライブラリ"
	},
	"bfs": {
		"prefix": "bfs",
		"body": [
			"// 各座標に格納したい情報を構造体にする",
			"// 今回はX座標,Y座標,深さ(距離)を記述している",
			"struct Corr {",
			"\tint x;",
			"\tint y;",
			"\tint depth;",
			"};",
			"queue<Corr> q;",
			"int bfs(vector<vector<int>> grid) {",
			"\t// 既に探索の場所を1，探索していなかったら0を格納する配列",
			"\tvector<vector<int>> ispassed(grid.size(), vector<int>(grid[0].size(), false));",
			"\t// このような記述をしておくと，この後のfor文が綺麗にかける",
			"\tint dx[8] = {1, 0, -1, 0};",
			"\tint dy[8] = {0, 1, 0, -1};",
			"\twhile(!q.empty()) {",
			"\t\tCorr now = q.front();q.pop();",
			"\t\t/*",
			"\t\t\t今いる座標は(x,y)=(now.x, now.y)で，深さ(距離)はnow.depthである",
			"\t\t\tここで，今いる座標がゴール(探索対象)なのか判定する",
			"\t\t*/",
			"\t\tfor(int i = 0; i < 4; i++) {",
			"\t\t\tint nextx = now.x + dx[i];",
			"\t\t\tint nexty = now.y + dy[i];",
			"",
			"\t\t\t// 次に探索する場所のX座標がはみ出した時",
			"\t\t\tif(nextx >= grid[0].size()) continue;",
			"\t\t\tif(nextx < 0) continue;",
			"",
			"\t\t\t// 次に探索する場所のY座標がはみ出した時",
			"\t\t\tif(nexty >= grid.size()) continue;",
			"\t\t\tif(nexty < 0) continue;",
			"",
			"\t\t\t// 次に探索する場所が既に探索済みの場合",
			"\t\t\tif(ispassed[nexty][nextx]) continue;",
			"",
			"\t\t\tispassed[nexty][nextx] = true;",
			"\t\t\tCorr next = {nextx, nexty, now.depth+1};",
			"\t\t\tq.push(next);",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "幅優先探索"
	},
	"RollingHash": {
		"prefix": "RollingHash",
		"body": [
			"std::mt19937 mt{ std::random_device{}() };",
			"std::uniform_int_distribution<int> dist(129, INF);",
			"const int BASE = dist(mt);",
			"",
			"class RollingHash {",
			"public:",
			"\tstring str;",
			"\tvector<ull> powBase, csumHash;",
			"\tconst ull ROLMOD = (1LL << 61) - 1;",
			"\tconst ull MASK30 = (1LL << 30) - 1;",
			"\tconst ull MASK31 = (1LL << 31) - 1;",
			"\tconst ull LLMAX = ROLMOD*((1LL << 3) - 1);",
			"",
			"\tRollingHash(const string s) : str(s) {",
			"\t\tpowBase.resize(s.size() + 1);",
			"\t\tcsumHash.resize(s.size() + 1);",
			"\t\tpowBase[0] = 1;",
			"\t\tfor(int i = 0; i < s.size(); i++) {",
			"\t\t\tpowBase[i + 1] = calcMod(multiple(powBase[i], BASE));",
			"\t\t}",
			"\t}",
			"",
			"\tvoid rollingHash() {",
			"\t\tcsumHash[0] = 0;",
			"\t\tfor(int i = 0; i < str.size(); ++i) {",
			"\t\t\tcsumHash[i + 1] = calcMod(multiple(csumHash[i], BASE) + str[i]);",
			"\t\t}",
			"\t}",
			"",
			"\tull getHash(const int begin, const int length) {",
			"\t\treturn calcMod(csumHash[begin + length] + LLMAX - multiple(csumHash[begin], powBase[length]));",
			"\t}",
			"",
			"\tstring substr(const int begin) {",
			"\t\treturn str.substr(begin);",
			"\t}",
			"",
			"\tstring substr(const int begin, const int length) {",
			"\t\tif(length < 0) {",
			"\t\t\treturn str.substr(begin, str.size() + length - begin + 1);",
			"\t\t} else {",
			"\t\t\treturn str.substr(begin, length);",
			"\t\t}",
			"\t}",
			"",
			"private:",
			"\tull calcMod(const ull num) {",
			"\t\tconst ull modNum = (num & ROLMOD) + (num >> 61);",
			"\t\treturn (modNum >= ROLMOD) ? modNum - ROLMOD : modNum;",
			"\t}",
			"",
			"\tull multiple(const ull leftNum, const ull rightNum) {",
			"\t\tull lu = leftNum >> 31;",
			"\t\tull ld = leftNum & MASK31;",
			"\t\tull ru = rightNum >> 31;",
			"\t\tull rd = rightNum & MASK31;",
			"\t\tull middleBit = ld * ru + lu * rd;",
			"\t\treturn ((lu * ru) << 1) + ld * rd + ((middleBit & MASK30) << 31) + (middleBit >> 30);",
			"\t}",
			"",
			"};"
		],
		"description": "ローリングハッシュ(文字列探索)"
	},
	"codeforces": {
		"prefix": "codeforces",
		"body": [
			"int Q;",
			"cin >> Q;",
			"while(Q--) {",
			"\t$1",
			"}"
		],
		"description": "CodeForcesのテンプレート"
	},
	"LazySegmentTree": {
		"prefix": "LazySegmentTree",
		"body": [
			"template <typename T>",
			"class Sum {",
			"public:",
			"\t// 単位元",
			"\tT unit;",
			"\t",
			"\tSum(void) {",
			"\t\t// 単位元",
			"\t\tunit = 0;",
			"\t}",
			"",
			"\t// 演算関数",
			"\tT calc(T a, T b) {",
			"\t\treturn a + b; ",
			"\t}",
			"};",
			"",
			"template <typename T, class MONOID>",
			"class LazySegmentTree {",
			"public:",
			"\t// セグメント木の葉の要素数",
			"\tint n;",
			"",
			"\t// セグメント木",
			"\tvector<T> tree, lazy;",
			"",
			"\t// モノイド",
			"\tMONOID mono;",
			"",
			"\tLazySegmentTree(vector<T> &v) {",
			"\t\tn = 1 << (int)ceil(log2(v.size()));",
			"\t\ttree = vector<T>(n << 1);",
			"\t\tlazy = vector<T>(n << 1, mono.unit);",
			"\t\tfor(int i = 0; i < v.size(); ++i) {",
			"\t\t\tupdate(i, v[i]);",
			"\t\t}",
			"\t\tfor(int i = v.size(); i < n; ++i) {",
			"\t\t\tupdate(i, mono.unit);",
			"\t\t}",
			"\t}",
			"",
			"\t// k番目の値(0-indexed)をxに変更",
			"\tvoid update(int k, T x) {",
			"\t\tk += n;",
			"\t\ttree[k] = x;",
			"\t\tfor(k = k >> 1; k > 0; k >>= 1){",
			"\t\t\ttree[k] = mono.calc(tree[k << 1 | 0], tree[k << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\t// [l, r)の最小値(0-indexed)を求める．",
			"\tT query(int l, int r) {",
			"\t\tT res = mono.unit;",
			"\t\tl += n;",
			"\t\tr += n;",
			"\t\twhile(l < r) {",
			"\t\t\tif(l & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[l++]);",
			"\t\t\t}",
			"\t\t\tif(r & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[--r]);",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"",
			"\t// k番目のノードの遅延評価を行う",
			"\tvoid eval(int k, int l, int r) {",
			"\t\t// 遅延評価配列が空でない時，値を伝播する",
			"\t\tif(lazy[k] != mono.unit) {",
			"\t\t\ttree[k] += lazy[k];",
			"\t\t\tif(r - l > 1) {",
			"\t\t\t\tlazy[k<<1|0] += lazy[k]>>1;",
			"\t\t\t\tlazy[k<<1|1] += lazy[k]>>1;",
			"\t\t\t}",
			"",
			"\t\t\t// 伝播が終わったので自ノードの遅延配列を空にする",
			"\t\t\tlazy[k] = mono.unit;",
			"\t\t}",
			"\t}",
			"",
			"\t// 区間[l, r)にxを足す(遅延評価)",
			"\tvoid add(int l, int r, ll x) {",
			"\t\tadd(l, r, x, 1, 0, n);",
			"\t}",
			"",
			"\tvoid add(int a, int b, ll x, int k, int l, int r) {",
			"\t\t// k番目のノードに対して遅延評価を行う",
			"\t\teval(k, l, r);",
			"",
			"\t\t// 範囲外なら何もしない",
			"\t\tif(b <= l || r <= a) return;",
			"\t\t",
			"\t\t// 完全に被覆しているならば、遅延配列に値を入れた後に評価",
			"\t\tif(a <= l && r <= b) {",
			"\t\t\tlazy[k] += (r - l) * x;",
			"\t\t\teval(k, l, r);",
			"\t\t} else {",
			"\t\t\tadd(a, b, x, k<<1|0, l, (l + r)>>1);",
			"\t\t\tadd(a, b, x, k<<1|1, (l + r)>>1, r);",
			"\t\t\ttree[k] = tree[k<<1|0] + tree[k<<1|1];",
			"\t\t}",
			"\t}",
			"",
			"\t// 区間[l, r)の合計を取得する",
			"\tll getRange(int l, int r) {",
			"\t\treturn getRange(l, r, 1, 0, n);",
			"\t}",
			"",
			"\tll getRange(int a, int b, int k, int l, int r) {",
			"\t\tif(b <= l || r <= a) return mono.unit;",
			"\t\t// 関数が呼び出されたら評価！",
			"\t\teval(k, l, r);",
			"\t\tif(a <= l && r <= b) return tree[k];",
			"\t\tll vl = getRange(a, b, k<<1|0, l, (l + r)>>1);",
			"\t\tll vr = getRange(a, b, k<<1|1, (l + r)>>1, r);",
			"\t\treturn vl + vr;",
			"\t}",
			"",
			"\tT operator[](int k) {",
			"\t\t// st[i]で添字iの要素の値を返す",
			"\t\tif(k - n >= 0 || k < 0) {",
			"\t\t\treturn -INF;",
			"\t\t}",
			"\t\treturn tree[tree.size() - n + k];",
			"\t}",
			"",
			"\tvoid show(void) {",
			"\t\tshowTree();",
			"\t\tshowLazy();",
			"\t}",
			"",
			"\tvoid showTree(void) {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i < 2*n; ++i) {",
			"\t\t\tif(tree[i] == mono.unit) cout << \"UNIT \";",
			"\t\t\telse cout << tree[i] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid showLazy(void) {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i < 2*n; ++i) {",
			"\t\t\tif(lazy[i] == mono.unit) cout << \"UNIT \";",
			"\t\t\telse cout << lazy[i] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "遅延評価セグメント木"
	},
	"print_vector": {
		"prefix": "print_vector",
		"body": [
			"template<class T>",
			"void print_vector(vector<T> &v) {",
			"\trep(i, v.size()) {",
			"\t\tif(!i) cout << v[i];",
			"\t\telse cout << \" \" << v[i];",
			"\t}",
			"\tcout << endl;",
			"}"
		],
		"description": "配列の表示"
	},
	"lambdaSort": {
		"prefix": "lambdaSort",
		"body": [
			"template<class T>",
			"void lambdaSort(vector<T> &v) {",
			"\tsort(all(v), [](auto const& l, auto const& r) {",
			"\t\treturn l.fi > r.fi; // このbool式が成り立つ時入れ替える",
			"\t});",
			"}"
		],
		"description": "ラムダ式を使ったソート"
	},
	"BridgeArticulation": {
		"prefix": "BridgeArticulation",
		"body": [
			"class BridgeArticulation {",
			"\tint N, num = 0;",
			"\tvvi G;",
			"\tvi pre, low;",
			"\tvb isPassed;",
			"",
			"\tint culcLow(const int v, const int bef) {",
			"\t\tint nowLow = num;",
			"\t\tlow[v] = pre[v] = nowLow;",
			"\t\tfor(auto ne : G[v]) {",
			"\t\t\tif(ne == bef) continue;",
			"\t\t\tif(ne == 0) {",
			"\t\t\t\tlow[0] = -1;",
			"\t\t\t}",
			"\t\t\tif(pre[ne] == -1) {",
			"\t\t\t\tnum++;",
			"\t\t\t\tculcLow(ne, v);",
			"\t\t\t}",
			"\t\t\tchmin(nowLow, low[ne]);",
			"\t\t}",
			"\t\treturn low[v] = nowLow;",
			"\t}",
			"",
			"\tvoid traceGraph(const int v, const int bef) {",
			"\t\tbool is_articulation = false;",
			"\t\tfor(auto ne : G[v]) {",
			"\t\t\tif(ne == bef) continue;",
			"\t\t\tif(!isPassed[ne]) {",
			"\t\t\t\tif(low[ne] >= pre[v] && (bef != -1 || G[v].size() >= 2)) {",
			"\t\t\t\t\tis_articulation = true;",
			"\t\t\t\t}",
			"\t\t\t\tif(low[ne] == pre[ne]) {",
			"\t\t\t\t\tbridges.emplace_back(min(v, ne), max(v, ne));",
			"\t\t\t\t}",
			"\t\t\t\tisPassed[ne] = true;",
			"\t\t\t\ttraceGraph(ne, v);",
			"\t\t\t}",
			"\t\t}",
			"\t\tif(is_articulation) {",
			"\t\t\tarticulation.push_back(v);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tvpii bridges; // 橋",
			"\tvi articulation; // 関節点",
			"",
			"\tBridgeArticulation(const int _n, const vvi _G) : N(_n), G(_G) {",
			"\t\tpre = vi(N, -1);",
			"\t\tlow = vi(N, INF);",
			"\t\tisPassed = vb(N, false);",
			"\t\tisPassed[0] = true;",
			"\t}",
			"",
			"\tvoid findBridges() {",
			"\t\tculcLow(0, -1);",
			"\t\ttraceGraph(0, -1);",
			"\t\tSort(bridges);",
			"\t}",
			"",
			"\tvoid show() {",
			"\t\tfor(auto p : bridges) {",
			"\t\t\tcout << p.fi << \" \" << p.se << endl; ",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "無向グラフの橋を求める"
	},
	"mint_combination": {
		"prefix": "mint_combination",
		"body": [
			"#define MAX_MINT_NCK 201010",
			"mint f[MAX_MINT_NCK], rf[MAX_MINT_NCK];",
			"",
			"bool isinit = false;",
			"",
			"void init() {",
			"\tf[0] = 1;",
			"\trf[0] = 1;",
			"\tfor(int i = 1; i < MAX_MINT_NCK; i++) {",
			"\t\tf[i] = f[i - 1] * i;",
			"\t\t// rf[i] = modinv(f[i].x);",
			"\t\trf[i] = f[i].pow(f[i], MOD - 2);",
			"\t}",
			"}",
			"",
			"mint nCk(mint n, mint k) {",
			"\tif(n < k) return 0;",
			"\tif(!isinit) {",
			"\t\tinit();",
			"\t\tisinit = 1;",
			"\t}",
			"\tmint nl = f[n.x]; // n!",
			"\tmint nkl = rf[n.x - k.x]; // (n-k)!",
			"\tmint kl = rf[k.x]; // k!",
			"\tmint nkk = (nkl.x * kl.x);",
			"",
			"\treturn nl * nkk;",
			"}"
		],
		"description": "mintの二項定理"
	},
	"bit": {
		"prefix": "bit",
		"body": [
			"template <typename T>",
			"class BIT {",
			"\tint N;",
			"\tvector<T> tree;",
			"",
			"public:",
			"\tBIT(vector<T>& v) : N(v.size()), tree(vector<T>(v.size() + 1)) {",
			"\t\trep(i, v.size()) { add(i, v[i]); }",
			"\t}",
			"\tBIT(int n) : N(n), tree(vector<T>(n + 1)) {}",
			"",
			"\tvoid add(int i, T x = 1) {",
			"\t\tfor (++i; i <= N; i += i & -i) {",
			"\t\t\ttree[i] += x;",
			"\t\t}",
			"\t}",
			"",
			"\tT sum(int l) {  // [0, l)の和",
			"\t\tT x = 0;",
			"\t\tfor (; l; l -= l & -l) {",
			"\t\t\tx += tree[l];",
			"\t\t}",
			"\t\treturn x;",
			"\t}",
			"",
			"\tT sum(int l, int r) {  // [l, r)の和",
			"\t\treturn sum(r) - sum(l);",
			"\t}",
			"",
			"\tT sum_back(int l) {  // [l, N)の和",
			"\t\treturn sum(N) - sum(l);",
			"\t}",
			"};"
		],
		"description": "BIT(Fenwick Tree)"
	},
	"lca": {
		"prefix": "lca",
		"body": [
			"class LCA {",
			"\tint n;",
			"\tint MAX;",
			"\tvvi doubling, v;",
			"",
			"\tvoid init() {",
			"\t\trep(i, n) {",
			"\t\t\tfor(auto j : v[i]) {",
			"\t\t\t\tdoubling[0][j] = i;",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor(int i = 1; i < MAX; i++) {",
			"\t\t\trep(j, n) {",
			"\t\t\t\tdoubling[i][j] = doubling[i - 1][doubling[i - 1][j]];",
			"\t\t\t}",
			"\t\t}",
			"\t\tdepth[0] = 0;",
			"\t\tdfs(0, -1);",
			"\t}",
			"",
			"\tvoid dfs(const int crrPos, const int befPos) {",
			"\t\tfor(auto i : v[crrPos]) {",
			"\t\t\tif(i == befPos || depth[i] != -1) {",
			"\t\t\t\tcontinue;",
			"\t\t\t}",
			"\t\t\tdepth[i] = depth[crrPos] + 1;",
			"\t\t\tdfs(i, crrPos);",
			"\t\t}",
			"\t}",
			"",
			"public:",
			"\tvi depth;",
			"",
			"\t// vは0が根のbfs木にする．親->子のように辺を張る．",
			"\tLCA(vvi &_v) : v(_v), n(_v.size()) {",
			"\t\tMAX = ceil(log2(n));",
			"\t\tdoubling = vvi(MAX, vi(n, 0));",
			"\t\tdepth = vi(n, -1);",
			"\t\tinit();",
			"\t}",
			"",
			"\tvoid show(const int height = 0) {",
			"\t\trep(i, ((!height)?MAX:height)) {",
			"\t\t\tdump(doubling[i]);",
			"\t\t}",
			"\t\tdump(depth);",
			"\t}",
			"",
			"\t// ダブリングでVのnum個親の祖先を調べる",
			"\tint doublingNode(int V, const int num) {",
			"\t\trep(i, MAX) {",
			"\t\t\tif((1LL<<i) & num) {",
			"\t\t\t\tV = doubling[i][V];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn V;",
			"\t}",
			"",
			"\tint lca(int A, int B) {",
			"\t\t// Aのが深い位置にあるようにする",
			"\t\tif(depth[A] < depth[B]) {",
			"\t\t\tswap(A, B);",
			"\t\t}",
			"\t\tA = doublingNode(A, depth[A] - depth[B]);",
			"\t\tif(A == B) {",
			"\t\t\treturn A;",
			"\t\t}",
			"",
			"\t\tfor (int k = MAX - 1; k >= 0; k--) {",
			"\t\t\tif (doubling[k][A] != doubling[k][B]) {",
			"\t\t\t\tA = doubling[k][A];",
			"\t\t\t\tB = doubling[k][B];",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn doubling[0][A];",
			"\t}",
			"};"
		],
		"description": "LCA(最近共通祖先)"
	},
	"MaximumFlow": {
		"prefix": "MaximumFlow",
		"body": [
			"class MaximumFlow {",
			"",
			"\tint v;",
			"",
			"\t// 辺を表す構造体(行き先，容量，逆辺のインデックス)",
			"\tstruct edge {",
			"\t\tint to;",
			"\t\tint cap;",
			"\t\tint rev;",
			"\t};",
			"",
			"\tvector<vector<edge>> G; // グラフの隣接リスト表現",
			"\tvector<bool> used; // DFSですでに調べたかのフラグ",
			"",
			"\t// 増加パスをDFSで探す(今いる頂点, ゴールの頂点, 今の頂点以降のフローの最小値)",
			"\tint dfs(int v, int t, int f) {",
			"\t\tif (v == t) return f;",
			"\t\tused[v] = true;",
			"\t\tfor (int i = 0; i < G[v].size(); i++) {",
			"\t\t\t// vから行ける&&cap>0の頂点を全てたどる",
			"\t\t\tedge& e = G[v][i];",
			"\t\t\tif (!used[e.to] && e.cap > 0) {",
			"\t\t\t\t// 次の頂点(e.to)以降でtまで行けるパスを探索し，その時のフローの最小値をdとする",
			"\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));",
			"\t\t\t\tif (d > 0) {",
			"\t\t\t\t\te.cap -= d;",
			"\t\t\t\t\tG[e.to][e.rev].cap += d;",
			"\t\t\t\t\treturn d;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn 0;",
			"\t}",
			"",
			"public:",
			"\tMaximumFlow(int _v) : v(_v) {",
			"\t\tused = vector<bool>(v);",
			"\t\tG = vector<vector<edge>>(v);",
			"\t}",
			"",
			"\t// fromからtoへ向かう容景capの辺をグラフに追加する",
			"\tvoid add(int from, int to, int cap) {",
			"\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});",
			"\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});",
			"\t}",
			"",
			"\t// sからtへの最大流を求める",
			"\tint maxFlow(int s, int t) {",
			"\t\tint flow = 0;",
			"\t\twhile (true) {",
			"\t\t\tused = vector<bool>(v);",
			"\t\t\tint f = dfs(s, t, INF);",
			"\t\t\tif (f == 0) {",
			"\t\t\t\treturn flow;",
			"\t\t\t}",
			"\t\t\tflow += f;",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "最大流"
	},
	"MinCostFlow": {
		"prefix": "MinCostFlow",
		"body": [
			"class MinCostFlow {",
			"",
			"\tint V; // 頂点数",
			"",
			"\t// 辺を表す構造体(行き先，容量，逆辺のインデックス)",
			"\tstruct edge {",
			"\t\tint to;",
			"\t\tint cap;",
			"\t\tint cost;",
			"\t\tint rev;",
			"\t};",
			"",
			"\tvector<vector<edge>> G; // グラフの隣接リスト表現",
			"\tvector<int> h; // ポテンシャル",
			"\tvector<int> prevV; // 直前の頂点",
			"\tvector<int> prevE; // 直前の辺",
			"\tvector<int> dist; // 最短距離",
			"\ttypedef pair<int, int> PI;",
			"",
			"public:",
			"\tMinCostFlow(int _v) : V(_v) {",
			"\t\tG = vector<vector<edge>>(V);",
			"\t\th = vector<int>(V);",
			"\t\tprevV = vector<int>(V);",
			"\t\tprevE = vector<int>(V);",
			"\t}",
			"",
			"\t// fromからtoへ向かう容景capの辺をグラフに追加する",
			"\tvoid add(int from, int to, int cap, int cost) {",
			"\t\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});",
			"\t\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});",
			"\t}",
			"",
			"\t// sからtへの最大流を求める",
			"\tint minCostFlow(int s, int t, int f) {",
			"\t\tint res = 0;",
			"\t\twhile (f > 0) {",
			"\t\t\t// ダイクストラ法を用いてhを更新する",
			"\t\t\tpriority_queue<PI, vector<PI>, greater<PI>> que;",
			"\t\t\tdist = vector<int>(V, INF);",
			"\t\t\tdist[s] = 0;",
			"\t\t\tque.push(PI(0, s));",
			"\t\t\twhile(!que.empty()) {",
			"\t\t\t\tPI p = que.top();",
			"\t\t\t\tque.pop();",
			"\t\t\t\tint v = p.second;",
			"\t\t\t\tif(dist[v] < p.first) continue;",
			"\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {",
			"\t\t\t\t\tedge e = G[v][i];",
			"\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
			"\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
			"\t\t\t\t\t\tprevV[e.to] = v;",
			"\t\t\t\t\t\tprevE[e.to] = i;",
			"\t\t\t\t\t\tque.push(PI(dist[e.to], e.to));",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif(dist[t] == INF) {",
			"\t\t\t\t// これ以上流せない",
			"\t\t\t\treturn -1;",
			"\t\t\t}",
			"\t\t\tfor(int v = 0; v < V; v++) {",
			"\t\t\t\th[v] += dist[v];",
			"\t\t\t}",
			"\t\t\t// s-t問最短路に沿って目一杯流す",
			"\t\t\tint d = f;",
			"\t\t\tfor(int v = t; v != s; v = prevV[v] ) {",
			"\t\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);",
			"\t\t\t}",
			"\t\t\tf -= d;",
			"\t\t\tres += d*h[t];",
			"\t\t\tfor(int v = t; v != s; v = prevV[v]) {",
			"\t\t\t\tedge& e = G[prevV[v]][prevE[v]];",
			"\t\t\t\te.cap -= d;",
			"\t\t\t\tG[v][e.rev].cap += d;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"};"
		],
		"description": "最小費用流"
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"template <int char_size, int base>",
			"class Trie {",
			"public:",
			"\tstruct Node {",
			"\t\tvector<int> next;    // 子の頂点番号を格納。存在しなければ-1",
			"\t\tvector<int> accept;  // 末端がこの頂点になる文字列(受理状態)のID",
			"\t\tint c;               // 文字，baseからの距離",
			"\t\tint common;          // いくつの文字列がこの頂点を共有しているか",
			"\t\tNode(int c_) : c(c_), common(0) { next = vector<int>(char_size, -1); }",
			"\t};",
			"\tvector<Node> nodes;  // trie 木本体",
			"\tTrie() { nodes.push_back(Node(0)); }",
			"",
			"\t/*",
			"\t単語の検索",
			"\tprefix ... 先頭のwordが一致していればいいかどうか",
			"\t*/",
			"\tbool search(const string word, const bool prefix = false) {",
			"\t\tint node_id = 0;",
			"\t\tfor (auto w : word) {",
			"\t\t\tint c = w - base;",
			"\t\t\tint next_id = nodes[node_id].next[c];",
			"\t\t\t// printf(\"%c %d %d\n\",w,c,next_id);",
			"\t\t\tif (next_id == -1) {",
			"\t\t\t\treturn false;",
			"\t\t\t}",
			"\t\t\tnode_id = next_id;",
			"\t\t}",
			"\t\treturn (prefix) ? true : nodes[node_id].accept.size();",
			"\t}",
			"",
			"\t/*",
			"\t単語の挿入",
			"\tword_id ... 何番目に追加する単語か",
			"\t*/",
			"\tvoid insert(const string &word) {",
			"\t\tint node_id = 0;",
			"\t\tfor (auto w : word) {",
			"\t\t\tint c = w - base;",
			"\t\t\tint next_id = nodes[node_id].next[c];",
			"\t\t\tif (next_id == -1) {  // 次の頂点が存在しなければ追加",
			"\t\t\t\tnext_id = nodes.size();",
			"\t\t\t\tnodes.push_back(Node(c));",
			"\t\t\t\tnodes[node_id].next[c] = next_id;",
			"\t\t\t}",
			"\t\t\t++nodes[node_id].common;",
			"\t\t\tnode_id = next_id;",
			"\t\t}",
			"\t\t++nodes[node_id].common;",
			"\t\tnodes[node_id].accept.push_back(nodes[0].common - 1); // 単語の終端なので、頂点に番号を入れておく",
			"\t}",
			"",
			"\t/*",
			"\tprefixの検索",
			"\t*/",
			"\tbool start_with(const string& prefix) { return search(prefix, true); }",
			"",
			"\t/*",
			"\t挿入した単語数",
			"\t*/",
			"\tint count() const { return nodes[0].common; }",
			"",
			"\t/*",
			"\t頂点数",
			"\t*/",
			"\tint size() const { return nodes.size(); }",
			"};"
		],
		"description": "Trie木"
	}
}