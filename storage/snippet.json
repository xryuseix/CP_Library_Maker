
{
	"gcd": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a;}"
		],
		"description": "ユークリッドの互除法"
	},
	"next_permutation": {
		"prefix": "next_permutation",
		"body": [
			"template <class BidirectionalIterator>",
			"bool generic_next_permutation(BidirectionalIterator first, BidirectionalIterator last) {",
    			"\t// 要素が０又は１の場合終了",
    			"\tif (first == last) return false;",
    			"\tBidirectionalIterator second = first;",
    			"\t++second;",
    			"\tif (second == last) return false;",
 				"\tBidirectionalIterator i = last;",
    			"\t--i;   // itを最後尾にセット",
    			"\twhile (true) {",
					"\t\tBidirectionalIterator prev_i = i;",
					"\t\tif (*(--i) < *prev_i) {",
						"\t\t\tBidirectionalIterator j = last;",
						"\t\t\twhile (!(*i < *--j));",
						"\t\t\tswap(*i, *j);",
						"\t\t\treverse(prev_i, last);",
						"\t\t\treturn true;",
					"\t\t}",
					"\t\tif (i == first) {",
						"\t\t\treverse(first, last);",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
			"}"
		],
		"description": "next_permutation"
	},
	"lcm": {
		"prefix": "lcm",
		"body": [
			"// gcdも呼ぶ！！！",
			"ll lcm(ll a, ll b) { return a / gcd(a,   b) * b;}"
		],
		"description": "最小公倍数"
	},
	"nlcm": {
		"prefix": "nlcm",
		"body": [
			"// gcdも呼ぶ！！！",
			"// lcmも呼ぶ！！！",
			"int nlcm(vector<int> numbers) {",
				"\tint l;",
				"\tl = numbers[0];",
				"\tfor (int i = 1; i < numbers.size(); i++) {",
					"\t\tl = lcm(l, numbers[i]);",
				"\t}",
				"\treturn l;",
			"}"
			  
		],
		"description": "n個の値の最小公倍数"
	},
	"union_find": {
		"prefix": "union_find",
		"body": [
			"class UnionFind {",
			"public:",
				"\t// 親の番号を格納する。親だった場合は-(その集合のサイズ)",
				"\tvector<int> Parent;",
				"",
				"\tUnionFind(int N) {",
					"\t\tParent = vector<int>(N, -1);",
				"\t}",
				"",
				"\t// Aがどのグループに属しているか調べる",
				"\tint root(int A) {",
					"\t\tif (Parent[A] < 0) return A;",
					"\t\treturn Parent[A] = root(Parent[A]);",
				"\t}",
				"",
				"\t// 自分のいるグループの頂点数を調べる",
				"\tint size(int A) {",
					"\t\treturn -Parent[root(A)];//親をとってきたい]",
				"\t}",
				"",
				"\t// AとBをくっ付ける",
				"\tbool connect(int A, int B) {",
					"\t\t// AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける",
					"\t\tA = root(A);",
					"\t\tB = root(B);",
					"\t\tif (A == B) {",
						"\t\t\t//すでにくっついてるからくっ付けない",
						"\t\t\treturn false;",
					"\t\t}",
					"",
					"\t\t// 大きい方(A)に小さいほう(B)をくっ付ける",
					"\t\t// 大小が逆だったらひっくり返す",
					"\t\tif (size(A) < size(B)) {",
						"\t\t\tswap(A, B);",
					"\t\t}",
					"",
					"\t\t// Aのサイズを更新する",
					"\t\tParent[A] += Parent[B];",
					"\t\t// Bの親をAに変更する",
					"\t\tParent[B] = A;",
					"",
					"\t\treturn true;",
				"\t}",
			"};"
		],
		"description": "Union-Find木"
	},
	"eratosthenes": {
		"prefix": "eratosthenes",
		"body": [
			"vector<bool> eratosmake(int n,vector<bool> num){",
				"\t// 整数を列挙して素数の候補とする",
				"\tfor(int i = 0; i < n; i++) num[i] = true;",
				"\t// 0と1を消す",
				"\tnum[0] = num[1] = false;",
				"\t// iを残してiの倍数を消していく",
				"\tfor(int i = 2; i < n; i++){",
					"\t\tif(num[i]){",
						"\t\t\tfor(int j = i + i; j < n; j += i){",
							"\t\t\t\tnum[j] = false;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\treturn num;",
			"}"
		],
		"description": "エラトステネスの篩"
	},
	"quicksort": {
		"prefix": "quicksort",
		"body": [
			"#define QsoetN 10",
			"int a[QsoetN];",
			"void quicksort(int a[], int first, int last){",
				"\tint i, j, x;",

				"\tx = a[(first + last)/2];",
				"\ti = first;",
				"\tj = last;",
				"\twhile(1){",
					"\t\twhile(a[i] < x) i++;",
					"\t\twhile(x < a[j]) j--;",
					"\t\tif(i >= j) break;",
					"\t\tswap(a[i], a[j]);",
					"\t\ti++;",
					"\t\tj--;",
				"\t}",
				"\tif(first < i - 1) quicksort(a, first, i - 1);",
				"\tif(j + 1 < last) quicksort(a, j + 1, last);",
			"}"
		],
		"description": "クイックソートですがsort関数で十分です"
	},
	"ngcd": {
		"prefix": "ngcd",
		"body": [
			"// gcdも呼ぶ！！！",
			"ll ngcd(vector<ll> a){",
			"\tll d;",
			"\td = a[0];",
			"\tfor(int i = 1; i < a.size() && d != 1; i++) d = gcd(a[i], d);",
			"\treturn d;",
			"}"
		],
		"description": "要素数がnの最大公約数"
	},
	"sanjihouteishiki":{
		"prefix": "sanjihouteishiki",
		"body": [
			"// 三次方程式 ax^3+bx^2+cx+d=0を解く ",
			"double ans1=0, ans2=0, ans3=0;",

			"void cardano(double a, double b, double c, double d){",
				"\tdouble p, q, t, a3, b3, x1, x2, x3;",
				"\tb /= (3*a); c /= a; d /= a;",
				"\tp = b*b - c/3;",
				"\tq = (b*(c - 2*b*b) - d)/2;",
				"\ta = q*q - p*p*p;",
				"\tif(a == 0){",
					"\t\tq = cbrt(q); x1 = 2*q - b; x2 = -q - b;",
					"\t\tcout << \"x=\" << x1 << \", \" << x2 << \"(重解)\" << endl;",
					"\t\tans1 = x1; ans2 = x2;",
				"\t}else if(a > 0){",
					"\t\tif(q > 0) a3 = cbrt(q + sqrt(a));",
					"\t\telse   a3 = cbrt(q - sqrt(a));",
					"\t\tb3 = p/a3;",
					"\t\tx1 = a3 + b3 - b; x2 = -0.5 + (a3 + b3) - b;",
					"\t\tx3 = fabs(a3 - b3)*sqrt(3.0)/2;",
					"\t\tcout << \"x=\" << x1 << \"; \" << x2 << \"+- \" << x3 << \"i\" << endl;",
					"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
				"\t}else{",
					"\t\ta = sqrt(p); t = acos(q/(p*a)); a *= 2;",
					"\t\tx1 = a*cos(t/3) - b;",
					"\t\tx2 = a*cos((t+2*M_PI)/3) - b;",
					"\t\tx3 = a*cos((t+4*M_PI)/3) - b;",
					"\t\tcout << \"x=\" << x1 << \", \" << x2 << \", \" << x3 << endl;",
					"\t\tans1 = x1; ans2 = x2; ans3 = x3;",
				"\t}",
			"}"
		],
		"description": "カルダノの公式を用いて三次方程式 ax^3+bx^2+cx+d=0 を解く "
	},
	"prime_dissasembly": {
		"prefix": "prime_dissasembly",
		"body": [
			"map<ll, ll> prime;",
			"void factorize(int n) {",
			"\tfor(int i = 2; i * i <= n; i++) {",
			"\t\twhile(n % i == 0) {",
			"\t\t\tprime[i]++;",
			"\t\t\tn /= i;",
			"\t\t}",
			"\t}",
			"\tif(n != 1) {",
			"\t\tprime[n] = 1;",
			"\t}",
			"}"
		],
		"description": "素因数分解"
	},
	"isPrime": {
		"prefix": "isPrime",
		"body": [
			"bool isPrime(int x){",
				"\tint i;",
				"\tif(x < 2)return 0;",
				"\telse if(x == 2) return 1;",
				"\tif(x%2 == 0) return 0;",
				"\tfor(i = 3; i*i <= x; i += 2) if(x%i == 0) return 0;",
				"\treturn 1;",
			"}"
		],
		"description": "素数判定（ O(√N) ）"
	},
	"hakidashi": {
		"prefix": "hakidashi",
		"body": [
			"#define RANK 20 // 20元連立方程式まで解ける",
			"/*",
			"使用方法",
				"\tdouble a[RANK][RANK+1];",
				"\tint i, n;",
				"\ta[0][0] = 2; a[0][1] = 3; a[0][2] = 1; a[0][3] = 4;",
				"\ta[1][0] = 4; a[1][1] = 1; a[1][2] = -3 ; a[1][3] = -2;",
				"\ta[2][0] = -1; a[2][1] = 2; a[2][2] = 2; a[2][3] = 2;",
				"\tn = 3;",
				"\thakidashi(a,n);",
			"*/",
			"void hakidashi(double a[][RANK+1], int n) { ",
				"\tdouble piv, t;",
				"\tint i, j, k;",
		
				"\tfor (k = 0; k < n; k++) {",
					"\t\tpiv = a[k][k];",
					"\t\tfor (j = k; j < n + 1; j++) {",
						"\t\t\ta[k][j] = a[k][j]/piv;",
					"\t\t}",
					"\t\tfor (i = 0; i < n; i++) {",
						"\t\t\tif (i != k) {",
							"\t\t\t\tt = a[i][k];",
							"\t\t\t\tfor (j = k; j < n+1; j++) {",
								"\t\t\t\t\ta[i][j] = a[i][j] - t*a[k][j];",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}"
		],
		"description": "掃き出し法"
	},
	"nijihouteishiki": {
		"prefix": "nijihouteishiki",
		"body": [
			"/*",
				"\taX^2+bX+c=0の解を求める",
				"\t出力はこんな感じ",
				"\tif(x1 == DBL_MIN)cout<<\"解なし\"<<endl;",
				"\telse if(x1==DBL_MAX)cout<<\"不定\"<<endl;",
				"\telse if(!i)cout<<x1<<\" , \"<<x2<<endl;",
				"\telse cout<<x1<<\" +- \"<<x2<<\"i\"<<endl;",
			"*/",
			"double x1, x2;",
			"bool i = false;",
			"void quadeq(double a, double b, double c){",
				"\tdouble d, x;",
				"\tif(a != 0){",
					"\t\tb /= a; c /= a;",
					"\t\tif(c != 0){",
						"\t\t\tb /= 2;",
						"\t\t\td = b*b - c;",
						"\t\t\tif(d > 0){",
							"\t\t\t\tif(b > 0) x = -b - sqrt(d);",
							"\t\t\t\telse x = -b + sqrt(d);",
							"\t\t\t\tx1 = x; x2 = c/x;",
						"\t\t\t}else if(d < 0){",
							"\t\t\t\tx1 = -b; x2 = sqrt(-d); i = true;",
						"\t\t\t}else{",
							"\t\t\t\tx1 = x2 = -b;",
						"\t\t\t}",
					"\t\t}else{",
						"\t\t\tx1 = -b; x2 = 0;",
					"\t\t}",
				"\t}else if(b != 0){",
					"\t\tx1 = x2 = -c/b;",
				"\t}",
				"\telse if(c != 0) x1 = x2 = DBL_MIN;",
				"\telse x1 = x2 = DBL_MAX;",
			"}"
		],
		"description": "二次方程式の解を求める"
	},
	"binary_search": {
		"prefix": "binary_search",
		"body": [
			"// vector vの中のn以下の数で最大のものを返す",
			"int bs(vector<int> v, int x){",
			"\tint ok = -1; //これがx以下 ",
			"\tint ng = v.size(); //x以上 ",
			"\t// 問題によってokとngを入れ替える",
			"\twhile(abs(ok - ng) > 1){",
			"\t\tint mid = (ok + ng)/2;",
			"\t\tif(v[mid] <= x) ok = mid;",
			"\t\telse ng = mid;",
			"\t}",
			"\treturn ok;",
			"}"
		],
		"description": "二分探索"
	},
	"yakusu_enum": {
		"prefix": "yakusu_enum",
		"body": [
			"vector<int> enum_div(int n){",
			"\tvector<int> ret;",
			"\tfor(int i = 1 ; i*i <= n ; ++i){",
			"\t\tif(n%i == 0){",
			"\t\t\tret.push_back(i);",
			"\t\t\tif(i != 1 && i*i != n){",
			"\t\t\t\tret.push_back(n/i);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\treturn ret;",
			"}"
		],
		"description": "約数列挙"
	},
	"mnmod": {
		"prefix": "mnmod",
		"body": [
			"// xのn乗%modを計算",
			"ll mod_pow(ll x,ll n,ll mod){",
			"\tll res = 1;",
			"\twhile(n > 0){",
			"\t\tif(n & 1) res = res*x%mod;",
			"\t\tx = x*x%mod;",
			"\t\tn >>= 1;",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "mのn乗modPを計算"
	},
	"stringcount": {
		"prefix": "stringcount",
		"body": [
			"int stringcount(string s, char c) {",
			"\treturn count(s.cbegin(), s.cend(), c);",
			"}"
		],
		"description": "文字列中の特定の文字の個数をカウント"
	},
	"zip": {
		"prefix": "zip",
		"body": [
			"map<int,int> zip;",

			"int compress(vector<int> x) {",
		    "\tint unzip[x.size()];",
		    "\tsort(x.begin(), x.end());",
		    "\tx.erase(unique(x.begin(),x.end()),x.end());",
		    "\tfor(int i = 0; i < x.size(); i++){",
	        "\t\tzip[x[i]] = i;",
	        "\t\tunzip[i] = x[i];",
		    "\t}",
		    "\treturn x.size();",
			"}"
		],
		"description": "一次元座標圧縮"
	},
	"bitsearch": {
		"prefix": "bitsearch",
		"body": [
			"// {0, 1, ..., n-1} の部分集合の全探索",
			"void bitsearch(int n) {",
			"\tfor(int bit = 0; bit < (1<<n); ++bit){",
			"\t\t/* bit で表される集合の処理を書く */",
			"\t\t",
			"\t\t/* きちんとできていることを確認してみる */",
			"\t\t// bit の表す集合を求める",
			"\t\tvector<int> S;",
			"\t\tfor(int i = 0; i < n; ++i) {",
			"\t\t\tif(bit & (1<<i) ){ // i が bit に入るかどうか",
			"\t\t\t\tS.push_back(i);",
			"\t\t\t}",
			"\t\t}",
			"\t\t",
			"\t\t// bit の表す集合の出力",
			"\t\tcout << bit << \": {\";",
			"\t\tfor(int  i = 0; i < S.size(); ++i) {",
			"\t\t\tcout << S[i] << \" \";",
			"\t\t}",
			"\t\tcout << \"}\" << endl;",
			"\t}",
			"}"
		],
		"description": "bit全探索"
	},
	"Pascal": {
		"prefix": "Pascal",
		"body": [	
			"bool useinit = false;",
			"int combMax = 4000;",
			"vector<vector<ll> > comb(combMax + 2, vector<ll> (combMax + 2));",
			"void init(void) {",
				"\tcomb[0][0] = 1;",
				"\tfor(int i = 0; i <= combMax; i++){",
					"\t\tfor(int j = 0; j <= i; j++){",
						"\t\t\tcomb[i + 1][j] += comb[i][j];",
						"\t\t\tcomb[i + 1][j + 1] += comb[i][j];",
					"\t\t}",
				"\t}",
			"}",
			"int Pascal(int n,int k){",
				"\tif(!useinit){",
					"\t\tinit();",
					"\t\tuseinit = true;",
				"\t}",
				"\treturn comb[n][k];",
			"}"
		],
		"description": "組み合わせ・PascalでnCkを求める"
	},
	"modint": {
		"prefix": "modint",
		"body": [
			"const int mod = 1000000007;",
			"struct mint {",
				"\tll x;",
				"\tmint(ll x=0):x(x%mod){}",
				"\tmint& operator+=(const mint a) {",
					"\t\tif ((x += a.x) >= mod) x -= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint& operator-=(const mint a) {",
					"\t\tif ((x += mod-a.x) >= mod) x -= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint& operator*=(const mint a) {",
					"\t\t(x *= a.x) %= mod;",
					"\t\treturn *this;",
				"\t}",
				"\tmint operator+(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res+=a;",
				"\t}",
				"\tmint operator-(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res-=a;",
				"\t}",
				"\tmint operator*(const mint a) const {",
					"\t\tmint res(*this);",
					"\t\treturn res*=a;",
				"\t}",
			"};"
		],
		"description": ""
	},
	"knapsack": {
		"prefix": "knapsack",
		"body": [
			"int  knapsack(int n, int W, vi w, vi v){",
				"\tvvi dp(n + 1, vi (W + 1, 0));",
				"\tfor(int i = 1; i <= n; i++) {",
					"\t\tfor(int j = 1; j <= W; j++) {",
						"\t\t\tif(j - w[i] >= 0) {",
							"\t\t\t\tchmax(dp[i][j], dp[i - 1][j - w[i]] + v[i]);",
						"\t\t\t}",
						"\t\t\tchmax(dp[i][j], dp[i - 1][j]);",
					"\t\t}",
				"\t}",
				"\treturn dp[n][W];",
			"}"
		],
		"description": "ナップサック問題を解く"
	},
	"lcs": {
		"prefix": "lcs",
		"body": [
			"string lcs(string s, string t) {",
				"\tvvi dp(s.size() + 1, vi(t.size() + 1));",
				"\t",
				"\tfor(int i = 0; i < s.size(); i++) {//LCS",
					"\t\tfor(int j = 0; j < t.size(); j++) {",
						"\t\t\tif(s[i] == t[j]) {",
							"\t\t\t\tdp[i + 1][j + 1] = dp[i][j] + 1;",
						"\t\t\t}",
						"\t\t\telse{",
							"\t\t\t\tdp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\t// 復元",
				"\tstring ans = \"\";",
				"\tint i = (int)s.size(), j = (int)t.size();",
				"\twhile (i > 0 && j > 0){",
					"\t\t// (i-1, j) -> (i, j) と更新されていた場合",
					"\t\tif (dp[i][j] == dp[i-1][j]) {",
						"\t\t\t--i; // DP の遷移を遡る",
					"\t\t}",
					"\t\t// (i, j-1) -> (i, j) と更新されていた場合",
					"\t\telse if (dp[i][j] == dp[i][j-1]) {",
						"\t\t\t--j; // DP の遷移を遡る",
					"\t\t}",
					"\t\t// (i-1, j-1) -> (i, j) と更新されていた場合",
					"\t\telse {",
						"\t\t\tans = s[i-1] + ans;",
						"\t\t\t--i, --j; // DP の遷移を遡る",
					"\t\t}",
				"\t}",
				"\treturn ans;",
			"}"
		],
		"description": "最長共通部分列問題を解く"
	},
	"icpctemplate": {
		"prefix": "icpctemplate",
		"body": [
			"#include <iostream>",
			"#include <algorithm>",
			"#include <string>",
			"#include <vector>",
			"using namespace std;",
			"typedef long long int ll;",
			"typedef vector<int> vi;",
			"#define rep(i,n) for(int i = 0; i < (n); ++i)",
			"int main(void){}"
		],
		"description": "ICPCテンプレート"
	},
	"gpriority_queue": {
		"prefix": "gpriority_queue",
		"body": [
			"priority_queue<int, vector<int>, greater<int> > queue;"
		],
		"description": "int型一次元で昇順に取り出せるのpriority_queue"
	},
	"bellman_ford": {
		"prefix": "bellman_ford",
		"body": [
			"// 頂点fromから頂点toへのコストcostの辺",
			"struct bf_edge {",
				"\tint from;",
				"\tint to;",
				"\tint cost;",
			"};",
			"",
			"class Bellman_Ford{",
			"public:",
				"\tvector<bf_edge> es; // 辺",
				"\tvector<int> d; // d[i]...頂点sから頂点iまでの最短距離",
				"\tint V, E; // Vは頂点数、Eは辺数",
				"",
				"\tBellman_Ford(int v, int e) {",
					"\t\tV = v;",
					"\t\tE = e;",
					"\t\td = vector<int>(v);",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\tbf_edge ed = {from, to, cost};",
					"\t\tes.push_back(ed);",
				"\t}",
				"",
				"\t// s番目の頂点から各頂点への最短距離を求める",
				"\tvoid shortest_path(int s) {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\td[i] = INF;",
					"\t\t}",
					"\t\td[s] = 0;",
					"\t\twhile(true) {",
						"\t\t\tbool update = false;",
						"\t\t\tfor(int i = 0; i < E; i++) {",
							"\t\t\t\tbf_edge e = es[i];",
							"\t\t\t\tif(d[e.from] != INF && d[e.to] > d[e.from] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[e.from] + e.cost;",
								"\t\t\t\t\tupdate = true;",
							"\t\t\t\t}",
						"\t\t\t}",
						"\t\t\tif (!update) break;",
					"\t\t}",
				"\t}",
				"\t// trueなら負の閉路が存在する",
				"\tbool is_nagative_loop(void) {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\td[i] = 0;",
					"\t\t}",
					"\t\tfor (int i = 0; i < 3*V; i++) {",
						"\t\t\tfor(int j = 0; j < E; j++) {",
							"\t\t\t\tbf_edge e = es[j];",
							"\t\t\t\tif(d[e.to] > d[e.from] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[e.from] + e.cost;",
								"",
								"\t\t\t\t\t// 3n回目にも更新があるなら負の閉路が存在する",
								"\t\t\t\t\tif(i == V - 1)return true;",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn false;",
				"\t}",
			"};"
		],
		"description": "ベルマンフォード法"
	},
	"topological_sort": {
		"prefix": "topological_sort",
		"body": [
			"vvi G(1000); // グラフ(リスト)",
			"",
			"// トポロジカルソート",
			"void rec(int v, vector<bool> &seen, vector<int> &order) {",
				"\tseen[v] = true;",
				"\tcout<<v<<endl;",
				"\tfor (int i= 0; i < G[v].size(); i++) {",
					"\t\tint next = G[v][i];",
					"\t\tif (seen[next]) continue; // 既に訪問済みなら探索しない",
					"\t\trec(next, seen, order);",
				"\t}",
				"\torder.push_back(v);",
			"}",
			"",
			"vector<int> topo(int N) { // Nはノード数",
				"\t// 探索",
				"\tvector<bool> seen(N, 0); // 初期状態では全ノードが未訪問",
				"\tvector<int> order; // トポロジカルソート順",
				"\tfor (int v = 0; v < N; ++v) {",
					"\t\tif (seen[v]) continue; // 既に訪問済みなら探索しない",
					"\t\trec(v, seen, order);",
				"\t}",
				"\treverse(order.begin(), order.end());",
				"\treturn order;",
			"}"
		],
		"description": "トポロジカルソート"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"class DIJKSTRA {",
			"public:",
				"\tint V;",
				"",
				"\tstruct dk_edge {",
					"\t\tint to;",
					"\t\tint cost;",
				"\t};",
				"",
				"\ttypedef pair<int, int> PI; //firstは最短距離、secondは頂点の番号",
				"\tvector<vector<dk_edge> >G;",
				"\tvector<int> d; //これ答え。d[i]:=V[i]までの最短距離",
				"\tvector<int> prev; //経路復元",
				"",
				"\tDIJKSTRA(int size) {",
					"\t\tV = size;",
					"\t\tG = vector<vector<dk_edge> >(V);",
					"\t\tprev = vector<int> (V, -1);",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\tdk_edge e = {to, cost};",
					"\t\tG[from].push_back(e);",
				"\t}",
				"",
				"\tvoid dijkstra(int s) {",
					"\t\t//greater<P>を指定することでfirstが小さい順に取り出せるようにする",
					"\t\tpriority_queue<PI, vector<PI>, greater<PI> > que;",
					"\t\td = vector<int> (V, INF);",
					"\t\td[s] = 0;",
					"\t\tque.push(PI(0, s));",
					"",
					"\t\twhile(!que.empty()) {",
						"\t\t\tPI p = que.top();",
						"\t\t\tque.pop();",
						"\t\t\tint v = p.second;",
						"\t\t\tif(d[v] < p.first) continue;",
						"\t\t\tfor(int i = 0; i < G[v].size(); i++) {",
							"\t\t\t\tdk_edge e = G[v][i];",
							"\t\t\t\tif(d[e.to] > d[v] + e.cost) {",
								"\t\t\t\t\td[e.to] = d[v] + e.cost;",
								"\t\t\t\t\tprev[e.to] = v;",
								"\t\t\t\t\tque.push(PI(d[e.to], e.to));",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"\tvector<int> get_path(int t) {",
					"\t\tvector<int> path;",
					"\t\tfor(;t != -1; t = prev[t]) {",
						"\t\t\t//tがsになるまでprev[t]をたどっていく",
						"\t\t\tpath.push_back(t);",
					"\t\t}",
					"\t\t//このままだとt->sの順になっているので逆順にする",
					"\t\treverse(path.begin(),path.end());",
					"\t\treturn path;",
				"\t}",
				"\tvoid show(void) {",
					"\t\tfor(int i = 0; i < d.size()-1; i ++) {",
						"\t\t\tcout << d[i] << \" \";",
					"\t\t}",
					"\t\tcout << d[d.size()-1] << endl;",
				"\t}",
			"};"
		],
		"description": "ダイクストラ法"
	},
	"warshall_floyd": {
		"prefix": "warshall_floyd",
		"body": [
			"class WAR_FLY {",
			"public:",
				"\tvvi d; // 辺の数",
				"\tint V; // 頂点の数",
				"\t",
				"\tWAR_FLY(int n) {",
					"\t\tV = n;",
					"\t\td = vector<vector<int> > (n,vector<int>(n));",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tif(i == j) {",
								"\t\t\t\t\td[i][j] = 0;",
							"\t\t\t\t}",
							"\t\t\t\telse {",
								"\t\t\t\t\td[i][j] = INF;",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"",
				"\tvoid warshall_floyd(void) {",
					"\t\tfor(int k = 0; k < V; k++) {",
						"\t\t\tfor(int i = 0; i < V; i++) {",
							"\t\t\t\tfor(int j = 0; j < V; j++) {",
								"\t\t\t\t\td[i][j] = min((ll)d[i][j], (ll)d[i][k] + (ll)d[k][j]);",
							"\t\t\t\t}",
						"\t\t\t}",
					"\t\t}",
				"\t}",
				"",
				"\tvoid add(int from, int to, int cost) {",
					"\t\td[from][to] = cost;",
				"\t}",
				"",
				"\tbool is_negative_loop(void) {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tif(d[i][i] < 0) return true;",
					"\t\t}",
					"\t\treturn false;",
				"\t}",
				"",
				"\tvoid show(void) {",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tcout << d[i][j] << \" \";",
						"\t\t\t}",
						"\t\t\tcout << endl;",
					"\t\t}",
				"\t}",
			"};"
		],
		"description": "ワーシャルフロイド法"
	},
	"intersect": {
		"prefix": "intersect",
		"body": [
			"void intersect(set<int> &Set_A, set<int> &Set_B, set<int> &Set_res) {",
			"\tset_intersection(Set_A.begin(), Set_A.end(), Set_B.begin(), Set_B.end(), inserter(Set_res, Set_res.end()));",
			"}"
		],
		"description": "setのintersect"
	},
	"digitsum": {
		"prefix": "digitsum",
		"body": [
			"int digsum(int n) {",
				"\tint res = 0;",
				"\twhile(n > 0) {",
					"\t\tres += n%10;",
					"\t\tn /= 10;",
				"\t}",
				"\treturn res;",
			"}"
		],
		"description": "桁和"
	},
	"indexdintance": {
		"prefix": "indexdistance",
		"body": [
			"int indexdistance(vector<int> distance_array, char c) {",
			"\treturn static_cast<int>(std::distance(std::begin(distance_array), std::find(std::begin(distance_array), std::end(distance_array), c)));",
			"}"
		],
		"description": "特定の文字の配列内の添字"
	},
	"gyakugen": {
		"prefix": "gyakugen",
		"body": [
			"// (a/b)%P の場合は，(a%P)*modinv(b)%P とする",
			"ll modinv(ll a) {",
    			"\tll b = MOD, u = 1, v = 0;",
    			"\twhile (b) {",
					"\t\tll t = a / b;",
        			"\t\ta -= t * b; swap(a, b);",
        			"\t\tu -= t * v; swap(u, v);",
				"\t}",
    			"\tu %= MOD;",
    			"\tif (u < 0) u += MOD;",
    			"\treturn u;",
			"}"
		],
		"description": "逆元の計算"
	},
	"BoyerMoore": {
		"prefix": "BoyerMoore",
		"body": [
			"class BoyerMoore {",
				"\tpublic:",
				"\tstring text;",
				"\tstring pattern;",
				"\tint n;",
				"\tint m;",
				"\tmap<char, int> lambda;",
				"\tBoyerMoore(string text_, string pattern_) : ",
					"\t\ttext(text_), pattern(pattern_), n(text_.size()), m(pattern_.size()) {",
					"\t\tcompute_lambda();",
				"\t};",
				"\tvoid compute_lambda(void) {",
					"\t\tfor(int j = 1; j <= m; j++) {",
						"\t\t\tlambda[pattern.at(j - 1)] = j;",
					"\t\t}",
				"\t};",
				"\tint get_lambda(const char& c) {",
					"\t\tif (lambda.find(c) != lambda.end()) {",
						"\t\t\treturn lambda[c];",
					"\t\t} else {",
						"\t\t\treturn 0;",
					"\t\t}",
				"\t};",
				"\tbool match(void) {",
					"\t\tint s = 0;",
					"\t\twhile(s <= n - m) {",
						"\t\t\tint j = m;",
						"\t\t\twhile(j > 0 && pattern.at(j - 1) == text.at(s + j - 1)) {",
							"\t\t\t\tj--;",
						"\t\t\t}",
						"\t\t\tif(j == 0) {",
							"\t\t\t\treturn true;//ここを消すとsが文字列の位置を示す",
							"\t\t\t\ts++;",
						"\t\t\t} else {",
							"\t\t\t\ts += std::max(1, j - get_lambda(text.at(s + j - 1)));",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn false;",
				"\t};",
			"};"
		],
		"description": "BoyerMoore法(文字列探索アルゴリズム)"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"UnionFind uni(100);",
			"// Union-Findも呼んで！！そして上の書き換えて！！！",
			"struct kr_edge {",
				"\tint u; // 辺の片方，fromではないので二回辺を張る必要はない",
				"\tint v; // 辺のもう片方",
				"\tint cost;",
				"",
				"\t// コストの大小で順序定義",
				"\tbool operator<(const kr_edge& e) const {",
					"\t\treturn cost < e.cost;",
				"\t}",
			"};",
			"class Kruskal{",
				"\tpublic:",
				"",
				"\tbool comp(const kr_edge& e1, const kr_edge& e2) { // sort関数の比較関数",
					"\t\treturn e1.cost < e2.cost;",
				"\t}",
				"",
				"\tvector<kr_edge> es; // 辺の集合",
				"\tvector<kr_edge> minst; // 最小全域木に用いられる辺の集合",
				"\tint V, E; // 頂点数と辺数",
				"",
				"\tKruskal(int v) {",
					"\t\tV = v;",
				"\t}",
				"",
				"\tvoid add(int v, int u, int cost){",
					"\t\tkr_edge e = {v, u, cost};",
					"\t\tes.push_back(e);",
				"\t}",
				"",
				"\tint kruskal(void) {",
					"\t\tsort(es.begin(), es.end()); // kr_edge.costが小さい順にソートされる",
					"\t\tUnionFind uni(V); //union-findの初期化",
					"\t\tint res = 0;",
					"\t\tfor(int i = 0; i < es.size(); i++) {",
						"\t\t\tkr_edge e = es[i];",
						"\t\t\tif(uni.root(e.u) != uni.root(e.v)) {",
							"\t\t\t\tuni.connect(e.u, e.v);",
							"\t\t\t\tres += e.cost;",
							"\t\t\t\tminst.push_back(e);",
						"\t\t\t}",
					"\t\t}",
					"\t\treturn res;",
				"\t}",
				"",
				"\tvoid show(void) {",
					"\t\tvvi v(V, vi(V, -1));",
					"\t\tfor(int i = 0; i < minst.size(); i++) {",
						"\t\t\tv[minst[i].u][minst[i].v] = minst[i].cost;",
						"\t\t\tv[minst[i].v][minst[i].u] = minst[i].cost;",
					"\t\t}",
					"\t\tfor(int i = 0; i < V; i++) {",
						"\t\t\tfor(int j = 0; j < V; j++) {",
							"\t\t\t\tif(v[i][j] == -1) {",
								"\t\t\t\t\tprintf(\"  __ \");",
							"\t\t\t\t} else {",
								"\t\t\t\t\tprintf(\"%4d \", v[i][j]);",
							"\t\t\t\t}",
						"\t\t\t}",
						"\t\t\tcout << endl;",
					"\t\t}",
				"\t}",
			"};"
		],
		"description": "クラスカル法"
	},
	"hutei": {
		"prefix": "hutei",
		"body": [	
			"void hutei(int a, int b, int c, bool minus) {",
				"\tvector<int> arr;",
				"",
				"\t// A / B = div...mod",
				"\tint A = max(a, b);",
				"\tint B = min(a, b);",
				"\tint div, mod;",
				"",
				"\twhile(1) {",
					"\t\tdiv = A/B;",
					"\t\tmod = A%B;",
					"\t\tarr.push_back(div);",
					"",
					"\t\tA = B;",
					"\t\tB = mod;",
					"",
					"\t\tif(mod == 1) {",
						"\t\t\tbreak;",
					"\t\t}",
				"\t}",
				"",
				"\tvector<vector<int> > calc(2, vector<int> (arr.size() + 1, INF));",
				"",
				"\tfor(int i = 0; i < arr.size() - 1; i++) {",
					"\t\tcalc[0][i] = -arr[i];",
				"\t}",
				"\tcalc[1][arr.size() - 1] = -arr[arr.size() - 1];",
				"\tcalc[1][arr.size()] = 1;",
				"",
				"\tfor(int i = arr.size()-2; i >= 0; i--) {",
					"\t\tcalc[1][i] = calc[0][i]*calc[1][i + 1] + calc[1][i + 2];",
				"\t}",
				"",
				"\tint x = calc[1][0]*c;",
				"\tint y = calc[1][1]*c;",
				"",
				"\tif(minus) {",
					"\t\ty *= -1;",
				"\t}",
				"\tcout << a << \"(\" << b << \"m + \" << x << \")\";",
				"\tif(minus) {",
					"\t\tcout << \" - \";",
				"\t} else {",
					"\t\tcout << \" + \";",
				"\t}",
				"\tcout << b << \"(\" << a << \"m + \" << y << \")\" << \" = \" << c << endl;",
			"}"
		],
		"description": "不定方程式を解く"
	},
	"SegmentTree": {
		"prefix": "SegmentTree",
		"body": [
			"class Monoid {",
			"public:",
			"\t// 単位元",
			"\tint unit;",
			"\t",
			"\tMonoid(void) {",
			"\t\t// 単位元",
			"\t\tunit = INF;",
			"\t}",
			"",
			"\t// 演算関数",
			"\tint calc(int a, int b) {",
			"\t\treturn min(a, b); ",
			"\t}",
			"};",
			"",
			"class SegmentTree {",
			"public:",
			"\t// セグメント木の葉の要素数",
			"\tint n;",
			"",
			"\t// セグメント木",
			"\tvector<int> tree;",
			"",
			"\t// モノイド",
			"\tMonoid mono;",
			"",
			"\tSegmentTree(vector<int> &v) {",
			"\t\tn = 1 << (int)ceil(log2(v.size()));",
			"\t\ttree = vector<int>(n << 1);",
			"\t\tfor(int i = 0; i < v.size(); i++) {",
			"\t\t\tupdate(i, v[i]);",
			"\t\t}",
			"\t\tfor(int i = v.size(); i < n; i++) {",
			"\t\t\tupdate(i, mono.unit);",
			"\t\t}",
			"\t}",
			"",
			"\t// k番目の値(0-indexed)をxに変更",
			"\tvoid update(int k, int x) {",
			"\t\tk += n;",
			"\t\ttree[k] = x;",
			"\t\tfor(k = k >> 1; k > 0; k >>= 1){",
			"\t\t\ttree[k] = mono.calc(tree[k << 1 | 0], tree[k << 1 | 1]);",
			"\t\t}",
			"\t}",
			"",
			"\t// [l, r)の最小値(0-indexed)を求める．",
			"\tint query(int l, int r) {",
			"\t\tint res = mono.unit;",
			"\t\tl += n;",
			"\t\tr += n;",
			"\t\twhile(l < r) {",
			"\t\t\tif(l & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[l++]);",
			"\t\t\t}",
			"\t\t\tif(r & 1) {",
			"\t\t\t\tres = mono.calc(res, tree[--r]);",
			"\t\t\t}",
			"\t\t\tl >>= 1;",
			"\t\t\tr >>= 1;",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\tint operator[](int k) {",
			"\t\t// st[i]で添字iの要素の値を返す",
			"\t\tif(k - n >= 0 || k < 0) {",
			"\t\t\treturn -INF;",
			"\t\t}",
			"\t\treturn tree[tree.size()-n+k];",
			"\t}",
			"",
			"\tvoid show(void) {",
			"\t\tint ret = 2;",
			"\t\tfor(int i = 1; i < 2*n; i++) {",
			"\t\t\tcout << tree[i] << \" \";",
			"\t\t\tif(i == ret - 1) {",
			"\t\t\t\tcout << endl;",
			"\t\t\t\tret <<= 1;",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "セグメント木"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"int lis(vector<int>& v) {",
    			"\tvi dp(1, v[0]);",
    			"\tfor(int i = 1; i < v.size(); i++) {",
    			    "\t\tif(v[i] > dp[dp.size() - 1]) {",
    			        "\t\t\tdp.push_back(v[i]);",
    			    "\t\t} else {",
    			        "\t\t\tint pos = distance(lower_bound(dp.begin(), dp.end(), v[i]), dp.begin());",
    			        "\t\t\tdp[pos] = v[i];",
    			    "\t\t}",
    			"\t}",
    			"\treturn (int)dp.size();",
			"}"
		],
		"description": "LIS(最長増加部分列)を解く"
	},
	"conlis": {
		"prefix": "conlis",
		"body": [
			"int conlis(vector<int>& v) {",
    			"\tvi dp(v.size() + 1, 0);",
    			"\tint ans = 0;",
    			"\tfor(int i = 0; i < v.size(); i++) {",
        			"\t\tdp[v[i]] = dp[v[i] - 1] + 1;",
        			"\t\tans = max(ans, dp[v[i]]);",
    			"\t}",
    			"\treturn ans;",
			"}"
		],
		"description": "Continue LIS(最長連続増加部分列)を解く"
	},
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"// x,y に ax + by = gcd(a, b) を満たす値が格納される",
			"ll extgcd(ll a, ll b, ll &x, ll &y) {",
				"\tif (b == 0) {",
					"\t\tx = 1;",
					"\t\ty = 0;",
					"\t\treturn a;",
				"\t}",
				"\tll d = extgcd(b, a%b, y, x);",
				"\ty -= a/b * x;",
				"\treturn d;",
			"}"
		],
		"description": "拡張ユークリッドの互助法を解く"
	},
	"StronglyConnectedComponent": {
		"prefix": "StronglyConnectedComponent",
		"body": [
			"class StronglyConnectedComponent {",
			"public:",
			"\tint V;          // 頂点数",
			"\tint SubGraph;   // 強連結成分の数",
			"\tvvi Graph;      // グラフの隣接リスト表現",
			"\tvvi revGraph;   // 辺の向きを逆にしたグラフ",
			"\tvvi SmallGraph; // 強連結成分分解によって縮めたグラフ",
			"\tvi dfsline;     // 帰りがけ順の並び",
			"\tvi compo;       // cmp[i]で頂点iの属するグループ",
			"\tvb used;        // すでに調べたか",
			"",
			"\tStronglyConnectedComponent(int v) {",
			"\t\tV = v;",
			"\t\tGraph = vvi(v);",
			"\t\trevGraph = vvi(v);",
			"\t\tused = vb(v);",
			"\t\tcompo = vi(v);",
			"\t}",
			"",
			"\tint operator[](int k) {",
			"\t\t// scc[i]でi番目の頂点のグループ番号を返す",
			"\t\treturn compo[k];",
			"\t}",
			"",
			"\tvoid add_edge(int from, int to) {",
			"\t\tGraph[from].push_back(to);",
			"\t\trevGraph[to].push_back(from);",
			"\t}",
			"",
			"\tvoid dfs(int v) {",
			"\t\tused[v] = true;",
			"\t\tfor(int i = 0; i < Graph[v].size(); i++) {",
			"\t\t\tif(!used[Graph[v][i]]) dfs(Graph[v][i]);",
			"\t\t}",
			"\t\tdfsline.push_back(v);",
			"\t}",
			"",
			"\tvoid revdfs(int v, int k) {",
			"\t\tused[v] = true;",
			"\t\tcompo[v] = k;",
			"\t\tfor(int i = 0; i < revGraph[v].size(); i++) {",
			"\t\t\tif(!used[revGraph[v][i]]) revdfs(revGraph[v][i], k);",
			"\t\t}",
			"\t}",
			"",
			"\tint scc(void) {",
			"\t\tused = vb((int)used.size(), false);",
			"\t\tdfsline.clear();",
			"\t\tfor(int v = 0; v < V; v++) {",
			"\t\t\tif(!used[v]) dfs(v);",
			"\t\t}",
			"\t\tused = vb(used.size(), false);",
			"\t\tSubGraph = 0;",
			"\t\tfor(int i = dfsline.size() - 1; i >= 0; i--) {",
			"\t\t\tif(!used[dfsline[i]]) revdfs(dfsline[i], SubGraph++);",
			"\t\t}",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tcompo[i] = SubGraph - compo[i] - 1;",
			"\t\t}",
			"\t\treturn SubGraph;",
			"\t}",
			"",
			"\tvoid build(void) {",
			"\t\t// 縮めたグラフを構築する",
			"\t\tSmallGraph = vvi(SubGraph);",
			"\t\tfor (int i = 0; i < Graph.size(); i++) {",
			"\t\t\tfor(int j = 0; j < Graph[i].size(); j++) {",
			"\t\t\t\tint to = Graph[i][j];",
			"\t\t\t\tint s = compo[i], t = compo[to];",
			"\t\t\t\tif (s != t){",
			"\t\t\t\t\tSmallGraph[s].push_back(t);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\t// 被った辺を削除",
			"\t\t\tSmallGraph[i].erase(unique(SmallGraph[i].begin(), SmallGraph[i].end()), SmallGraph[i].end());",
			"\t\t}",
			"\t}",
			"",
			"\tvoid show_set_to_edge(void) {",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"集合\" << i << \"から出ている辺 : \";",
			"\t\t\tfor(int j = 0; j < SmallGraph[i].size(); j++) {",
			"\t\t\t\tcout << SmallGraph[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_group_of_node(void) {",
			"\t\tfor(int i = 0; i < V; i++) {",
			"\t\t\tcout << \"頂点\" << i << \"の属するグループ : \" << compo[i] << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid show_node_in_group(void) {",
			"\t\tvvi group(SubGraph);",
			"\t\tfor(int i = 0; i < compo.size(); i++) {",
			"\t\t\tgroup[compo[i]].push_back(i);",
			"\t\t}",
			"\t\tfor(int i = 0; i < SmallGraph.size(); i++) {",
			"\t\t\tcout << \"グループ\" << i << \"に属する頂点 : \";",
			"\t\t\tfor(int j = 0; j < group[i].size(); j++) {",
			"\t\t\t\tcout << group[i][j] << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"};"
		],
		"description": "強連結成分分解"
	},
	"CoordinateCompression": {
		"prefix": "CoordinateCompression",
		"body": [
			"class Compress{",
			"public:",
			"\tint before_W, before_H, N;",
			"\tvi before_X1, before_X2, before_Y1, before_Y2;",
			"\tint after_W, after_H;",
			"\tvi after_X1, after_X2, after_Y1, after_Y2;",
			"\t",
			"\t// (x1,y1) -> (x2, y2) の直線上のマスが塗られているとする",
			"\t// 点の場合は (x1,y1) == (x2, y2) とする",
			"\t// 四角形の場合は直線の集合とする",
			"\tCompress(int max_h, int max_w, int n, vi x1, vi x2, vi y1, vi y2) {",
			"\t\tbefore_H = max_h;",
			"\t\tbefore_W = max_w;",
			"\t\tN = n;",
			"\t\tbefore_X1 = x1;",
			"\t\tbefore_X2 = x2;",
			"\t\tbefore_Y1 = y1;",
			"\t\tbefore_Y2 = y2;",
			"\t\tafter_X1 = vi(max_w);",
			"\t\tafter_X2 = vi(max_w);",
			"\t\tafter_Y1 = vi(max_h);",
			"\t\tafter_Y2 = vi(max_h);",
			"\t}",
			"",
			"\tvoid compress(void) {",
			"\t\tafter_W = exec_compress(before_X1, before_X2, after_X1, after_X2, before_W, \"width\");",
			"\t\tafter_H = exec_compress(before_Y1, before_Y2, after_Y1, after_Y2, before_H, \"height\");",
			"\t}",
			"",
			"\tvoid before_show(void) {",
			"\t\tvvc v(before_H, vc(before_W, '_'));",
			"\t\tcout << \"H = \" << before_H << \", W = \" << before_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = before_Y1[i]; y <= before_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = before_X1[i]; x <= before_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, before_H){",
			"\t\t\trep(j, before_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"\tvoid after_show(void) {",
			"\t\tvvc v(after_H, vc(after_W, '_'));",
			"\t\tcout << \"H = \" << after_H << \", W = \" << after_W << endl;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tfor(int y = after_Y1[i]; y <= after_Y2[i]; y++) {",
			"\t\t\t\tfor(int x = after_X1[i]; x <= after_X2[i]; x++) {",
			"\t\t\t\t\tv[y][x] = '#';",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\trep(i, after_H){",
			"\t\t\trep(j, after_W){",
			"\t\t\t\tcout << v[i][j];",
			"\t\t\t}",
			"\t\t\tcout<<endl;",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"",
			"private:",
			"\tint exec_compress(vi &z1, vi &z2, vi &aft_z1, vi &aft_z2, int max_len, string mode) {",
			"\t\tvector<int> zs;",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\tif(z1[i] > z2[i]) swap(z1[i], z2[i]);",
			"",
			"\t\t\tzs.push_back(z1[i]);",
			"\t\t\tzs.push_back(z2[i]);",
			"",
			"\t\t\tif(mode == \"width\") {",
			"\t\t\t\tif(z2[i] + 1 <= max_len) zs.push_back(z2[i] + 1);",
			"\t\t\t} else if(mode == \"height\") {",
			"\t\t\t\tif(0 < z1[i] - 1) zs.push_back(z1[i] - 1);",
			"\t\t\t}",
			"\t\t}",
			"\t\tzs.push_back(1);",
			"\t\tzs.push_back(max_len);",
			"",
			"\t\tsort(zs.begin(), zs.end());",
			"\t\tzs.erase(unique(zs.begin(), zs.end()), zs.end());",
			"",
			"\t\tfor(int i = 0; i < N; i++) {",
			"\t\t\taft_z1[i] = find(zs.begin(), zs.end(), z1[i]) - zs.begin() + 1;",
			"\t\t\taft_z2[i] = find(zs.begin(), zs.end(), z2[i]) - zs.begin() + 1;",
			"\t\t}",
			"\t\treturn zs.size();",
			"\t}",
			"};"
		],
		"description": "二次元座標圧縮"
	},
	"template": {
		"prefix": "templete",
		"body": [
			"#include <iostream>",
			"#include <cstdio>",
			"#include <algorithm>",
			"#include <cmath>",
			"#include <vector>",
			"#include <list>",
			"#include <set>",
			"#include <map>",
			"#include <queue>",
			"#include <stack>",
			"#include <cctype>",
			"#include <cassert>",
			"#include <climits>",
			"#include <string>",
			"#include <bitset>",
			"#include <cfloat>",
			"#include <unordered_set>",
			"#pragma GCC optimize(\"Ofast\")",
			"using namespace std;",
			"typedef long double ld;",
			"typedef long long int ll;",
			"typedef unsigned long long int ull;",
			"typedef vector<int> vi;",
			"typedef vector<char> vc;",
			"typedef vector<bool> vb;",
			"typedef vector<double> vd;",
			"typedef vector<string> vs;",
			"typedef vector<ll> vll;",
			"typedef vector<pair<int,int> > vpii;",
			"typedef vector<vector<int> > vvi;",
			"typedef vector<vector<char> > vvc;",
			"typedef vector<vector<string> > vvs;",
			"typedef vector<vector<ll> > vvll;",
			"#define rep(i,n) for(int i = 0; i < (n); ++i)",
			"#define rrep(i,n) for(int i = 1; i <= (n); ++i)",
			"#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)",
			"#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)",
			"#define fin(ans) cout << (ans) << '\\n'",
			"#define STI(s) atoi(s.c_str())",
			"#define mp(p,q) make_pair(p, q)",
			"#define pb(n) push_back(n)",
			"#define all(a) a.begin(), a.end()",
			"#define rall(a) a.rbegin(), a.rend()",
			"#define Sort(a) sort(a.begin(), a.end())",
			"#define Rort(a) sort(a.rbegin(), a.rend())",
			"#define MATHPI acos(-1)",
			"#define itn int;",
			"int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};",
			"int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};",
			"template <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}",
			"template <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}",
			"struct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};",
			"const int INF = INT_MAX;",
			"const ll LLINF = 1LL<<60;",
			"const ll MOD = 1000000007;",
			"const double EPS = 1e-9;",
			"",
			"int main() {",
			"",
			"}"
		],
		"description": "テンプレート"
	},
	"combination": {
		"prefix": "combination",
		"body": [
			"#define MAX_NCK 101010",
			"ll f[MAX_NCK], rf[MAX_NCK];",
			"",
			"// modinvも呼ぶ！！",
			"",
			"bool isinit = false;",
			"",
			"void init(void) {",
			"\tf[0] = 1;",
			"\trf[0] = modinv(1);",
			"\tfor(int i = 1; i < MAX_NCK; i++) {",
			"\t\tf[i] = (f[i - 1] * i) % MOD;",
			"\t\trf[i] = modinv(f[i]);",
			"\t}",
			"}",
			"",
			"ll nCk(int n, int k) {",
			"\tif(!isinit) {",
			"\t\tinit();",
			"\t\tisinit = 1;",
			"\t}",
			"\tll nl = f[n]; // n!",
			"\tll nkl = rf[n - k]; // (n-k)!",
			"\tll kl = rf[k]; // k!",
			"\tll nkk = (nkl * kl) % MOD;",
			"",
			"\treturn (nl * nkk) % MOD;",
			"}"
		],
		"description": "組み合わせ・逆元でnCkを求める"
	},
	"kika": {
		"prefix": "kika",
		"body": [
			"/* ==== 幾何ライブラリ ==== */",
			"/* 点 */",
			"struct Point {",
			"\tdouble x;",
			"\tdouble y;",
			"\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}",
			"",
			"\t// === 四則演算の定義 ===",
			"\tfriend inline Point operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}",
			"\tfriend inline Point operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}",
			"\tfriend inline Point operator * (const Point &p, const double a) {return Point(p.x * a, p.y * a);}",
			"\tfriend inline Point operator * (const double a, const Point &p) {return Point(a * p.x, a * p.y);}",
			"\tfriend inline Point operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}",
			"\tfriend inline Point operator / (const Point &p, const double a) {return Point(p.x / a, p.y / a);}",
			"",
			"\t// === その他の演算 ===",
			"\t// 反時計回りに90度回転",
			"\tfriend Point rot90(const Point &p) {return Point(-p.y, p.x);}",
			"",
			"\t// 直線b,cからみて，aがどちら側にいるか判定",
			"\t// 1: bを上cを下とした時にaが右側にある, -1: aが左側にある, 0: aは直線bc上",
			"\tfriend int simple_ccw(const Point &a, const Point &b, const Point &c) {",
			"\t\tif(OuterProduct(b-a, c-a) > EPS) return 1;",
			"\t\tif(OuterProduct(b-a, c-a) < -EPS) return -1;",
			"\t\treturn 0;",
			"\t}",
			"",
			"\t// 内積",
			"\tfriend inline double InnerProduct(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}",
			"\t// 外積",
			"\tfriend inline double OuterProduct(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}",
			"",
			"\t// 二次元のノーム(ユークリッド距離)を計算",
			"\tfriend inline double norm2(const Point &p) {return sqrt(InnerProduct(p, p));}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}",
			"};",
			"",
			"/* 線 */",
			"struct Line {",
			"\tvector<Point> line;",
			"",
			"\tLine(void) {}",
			"\t// 線分の時",
			"\tLine(Point a, Point b = Point(0.0, 0.0)) {",
			"\t\t// x座標が小さい方->y座標が小さい順にしておく",
			"\t\tif(a.x > b.x) {",
			"\t\t\tswap(a, b);",
			"\t\t} else if(a.x == b.x && a.y > b.y) {",
			"\t\t\tswap(a, b);",
			"\t\t}",
			"\t\tline.push_back(a);",
			"\t\tline.push_back(b);",
			"\t}",
			"\t// 多角形などの時",
			"\tLine(vector<Point> L) {",
			"\t\t/*",
			"\t\t// 基本はソートするとバグるのでしないこと",
			"\t\tsort(L.begin(), L.end(), [](Point const& lhs, Point const& rhs) {",
			"\t\t\tif(lhs.x != rhs.x) return lhs.x < rhs.x;",
			"\t\t\telse if(lhs.y != rhs.y) return lhs.y < rhs.y;",
			"\t\t\treturn true;",
			"\t\t});",
			"\t\t*/",
			"\t\tline = L;",
			"\t}",
			"",
			"\t// === 出力 ===",
			"\tfriend ostream& operator << (ostream &s, const Line &l) {",
			"\t\ts << '{';",
			"\t\trep(i, l.line.size()) {",
			"\t\t\tif(i) {",
			"\t\t\t\ts << \", \";",
			"\t\t\t}",
			"\t\t\ts << l.line[i];",
			"\t\t}",
			"\t\ts << '}';",
			"\t\treturn s;",
			"\t}",
			"};",
			"",
			"/* 単位変換 */",
			"double torad(int deg) {return (double)(deg) * MATHPI / 180;}",
			"double todeg(double ang) {return ang * 180 / MATHPI;}",
			"",
			"/* 直線や多角形の交点 */",
			"Line crosspoint(const Line &L, const Line &M) {",
			"\tLine res;",
			"\tLine l = L;",
			"\tLine m = M;",
			"\tl.line.push_back(l.line[0]);",
			"\tm.line.push_back(m.line[0]);",
			"\tfor(int i = 0; i < l.line.size() - 1; i++) {",
			"\t\tfor(int j = 0; j < m.line.size() - 1; j++) {",
			"\t\t\tdouble d = OuterProduct(m.line[j + 1] - m.line[j], l.line[i + 1] - l.line[i]);",
			"\t\t\tif(abs(d) < EPS) continue;",
			"\t\t\tres.line.push_back(l.line[i] + (l.line[i + 1] - l.line[i]) * OuterProduct(m.line[j + 1] - m.line[j], m.line[j + 1] - l.line[i]) / d);",
			"\t\t}",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"/* 外心 */",
			"Point gaisin(const Point a, const Point b, const Point c) {",
			"\t// 外心は三角形の二つの辺の垂直二等分線の交点",
			"\tLine ab( (a + b)/2, (a + b)/2 + rot90(a - b) );",
			"\tLine bc( (b + c)/2, (b + c)/2 + rot90(b - c) );",
			"\treturn crosspoint(ab, bc).line[0];",
			"}",
			"",
			"/* 最小包含円 */",
			"double SmallestEnclosingCircle(const vector<Point> &V) {",
			"\tint N = V.size();",
			"\tif(N <= 1) return 0;",
			"",
			"\t// 最小包含円の中心の候補",
			"\tvector<Point> CenterCandidate;",
			"\tfor(int i = 0; i < N; i++) {",
			"\t\tfor(int j = i + 1; j < N; j++) {",
			"\t\t\t// 最小包含円の円弧上に点が２つしかないの時",
			"\t\t\tCenterCandidate.push_back( (V[i] + V[j]) / 2 );",
			"\t\t\tfor(int k = j + 1; k < N; k++) {",
			"\t\t\t\tif(!simple_ccw(V[i], V[j], V[k])) {",
			"\t\t\t\t\t// 三点が一直線上にある",
			"\t\t\t\t\tcontinue;",
			"\t\t\t\t}",
			"\t\t\t\t// 三点の外心が円の中心",
			"\t\t\t\tPoint r = gaisin(V[i], V[j], V[k]);",
			"\t\t\t\tCenterCandidate.push_back(r);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tdouble res = INF;",
			"\trep(c, CenterCandidate.size()) {",
			"\t\tdouble tmp = 0.0;",
			"\t\trep(v, V.size()) {",
			"\t\t\t// 中心からの距離が最大の点との距離が，包含円の半径になる",
			"\t\t\tchmax(tmp, norm2(V[v] - CenterCandidate[c]));",
			"\t\t}",
			"\t\t// 候補の包含円の中で，半径が最小の包含円が最小包含円になる．",
			"\t\tchmin(res, tmp);",
			"\t}",
			"\treturn res;",
			"}"
		],
		"description": "幾何ライブラリ"
	}
}


